#!/usr/bin/env python3

import os
import sys
import argparse
from abc import ABC, abstractmethod
from functools import cmp_to_key
import re
import csv
sys.path.append(os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "module_utils"))
from port_utils import get_port_alias_to_name_map  # noqa: E402


"""
csv field names
"""

devices_header = ["Hostname", "ManagementIp", "HwSku", "Type", "Protocol", "Os"]
links_header = ["StartDevice", "StartPort", "EndDevice", "EndPort", "BandWidth", "VlanID", "VlanMode", "AutoNeg"]
physical_links_header = ["StartDevice", "StartPort", "EndDevice", "EndPort", "BandWidth", "Cable"]
console_links_header = ["StartDevice", "StartPort", "EndDevice", "Console_type",
                        "Console_menu_type", "Proxy", "BaudRate"]


"""
Device info
"""

dut_ports_info = {
        "Arista-720DT-G48S4": [
            ("1000", ["etp{}".format(i + 1) for i in range(48)]),
            ("10000", ["etp{}".format(i + 1) for i in range(48, 52)]),
            ],
        "Mellanox-SN2700": [
            ("100000", ["etp{}".format(i + 1) for i in range(32)]),
            ],
        "Nokia-M0-7215": [
            ("1000", ["etp{}".format(i) for i in range(1, 49)]),
            ("10000", ["etp{}".format(i) for i in range(49, 53)]),
            ],
        "Nokia-7215": [
            ("1000", ["etp{}".format(i) for i in range(1, 49)]),
            ("10000", ["etp{}".format(i) for i in range(49, 53)]),
            ],
        "Nokia-7215-A1": [
            ("1000", ["etp{}".format(i) for i in range(1, 49)]),
            ("10000", ["etp{}".format(i) for i in range(49, 53)]),
            ],
        "Celestica-E1031-T48S4": [
            ("1000", ["etp{}".format(i) for i in range(1, 49)]),
            ("10000", ["etp{}".format(i) for i in range(49, 53)]),
            ],
        "Cisco-8102-C64": [
            ("100000", ["etp{}".format(i) for i in range(64)]),
            ],
        "ACS-MSN3800": [
            ("100000", ["etp{}".format(i + 1) for i in range(64)]),
            ],
        "Mellanox-SN4600C-C64": [
            ("100000", ["etp{}".format(i + 1) for i in range(64)]),
            ],
        "Arista-7260CX3-C64": [
            ("100000", ["Ethernet{}/1".format(i // 4 * 2 + i % 4 % 2 + i % 4 // 2 * 32 + 1) for i in range(64)]),
            ],
        "Arista-7260CX3-D108C8": [
            ("50000", ["Ethernet1/1", "Ethernet1/3", "Ethernet2/1", "Ethernet2/3", "Ethernet33/1", "Ethernet33/3",
                       "Ethernet34/1", "Ethernet34/3", "Ethernet3/1", "Ethernet3/3", "Ethernet4/1", "Ethernet4/3",
                       "Ethernet35/1", "Ethernet35/3", "Ethernet36/1", "Ethernet36/3", "Ethernet5/1", "Ethernet5/3",
                       "Ethernet6/1", "Ethernet6/3", "Ethernet37/1", "Ethernet37/3", "Ethernet38/1", "Ethernet38/3",
                       "Ethernet7/1", "Ethernet7/3", "Ethernet8/1", "Ethernet8/3", "Ethernet39/1", "Ethernet39/3",
                       "Ethernet40/1", "Ethernet40/3", "Ethernet9/1", "Ethernet9/3", "Ethernet10/1", "Ethernet10/3",
                       "Ethernet41/1", "Ethernet41/3", "Ethernet42/1", "Ethernet42/3", "Ethernet11/1", "Ethernet11/3",
                       "Ethernet12/1", "Ethernet12/3", "Ethernet43/1", "Ethernet43/3", "Ethernet44/1", "Ethernet44/3"]),
            ("100000", ["Ethernet13/1", "Ethernet14/1"]),
            ("50000", ["Ethernet45/1", "Ethernet45/3", "Ethernet46/1", "Ethernet46/3"]),
            ("100000", ["Ethernet15/1", "Ethernet16/1"]),
            ("50000", ["Ethernet47/1", "Ethernet47/3", "Ethernet48/1", "Ethernet48/3"]),
            ("100000", ["Ethernet17/1", "Ethernet18/1"]),
            ("50000", ["Ethernet49/1", "Ethernet49/3", "Ethernet50/1", "Ethernet50/3"]),
            ("100000", ["Ethernet19/1", "Ethernet20/1"]),
            ("50000", ["Ethernet51/1", "Ethernet51/3", "Ethernet52/1", "Ethernet52/3"]),
            ("50000", ["Ethernet21/1", "Ethernet21/3", "Ethernet22/1", "Ethernet22/3", "Ethernet53/1", "Ethernet53/3",
                       "Ethernet54/1", "Ethernet54/3", "Ethernet23/1", "Ethernet23/3", "Ethernet24/1", "Ethernet24/3",
                       "Ethernet55/1", "Ethernet55/3", "Ethernet56/1", "Ethernet56/3", "Ethernet25/1", "Ethernet25/3",
                       "Ethernet26/1", "Ethernet26/3", "Ethernet57/1", "Ethernet57/3", "Ethernet58/1", "Ethernet58/3",
                       "Ethernet27/1", "Ethernet27/3", "Ethernet28/1", "Ethernet28/3", "Ethernet59/1", "Ethernet59/3",
                       "Ethernet60/1", "Ethernet60/3", "Ethernet29/1", "Ethernet29/3", "Ethernet30/1", "Ethernet30/3",
                       "Ethernet61/1", "Ethernet61/3", "Ethernet62/1", "Ethernet62/3", "Ethernet31/1", "Ethernet31/3",
                       "Ethernet32/1", "Ethernet32/3", "Ethernet63/1", "Ethernet63/3", "Ethernet64/1", "Ethernet64/3"]),
            ],
        "Arista-7260CX3-D108C10": [
            ("100000", ["Ethernet1/1", "Ethernet2/1"]),
            ("50000", ["Ethernet33/1", "Ethernet33/3", "Ethernet34/1", "Ethernet34/3", "Ethernet3/1", "Ethernet3/3",
                       "Ethernet4/1", "Ethernet4/3", "Ethernet35/1", "Ethernet35/3", "Ethernet36/1", "Ethernet36/3",
                       "Ethernet5/1", "Ethernet5/3", "Ethernet6/1", "Ethernet6/3", "Ethernet37/1", "Ethernet37/3",
                       "Ethernet38/1", "Ethernet38/3", "Ethernet7/1", "Ethernet7/3", "Ethernet8/1", "Ethernet8/3",
                       "Ethernet39/1", "Ethernet39/3", "Ethernet40/1", "Ethernet40/3", "Ethernet9/1", "Ethernet9/3",
                       "Ethernet10/1", "Ethernet10/3", "Ethernet41/1", "Ethernet41/3", "Ethernet42/1", "Ethernet42/3",
                       "Ethernet11/1", "Ethernet11/3", "Ethernet12/1", "Ethernet12/3", "Ethernet43/1", "Ethernet43/3",
                       "Ethernet44/1", "Ethernet44/3"]),
            ("100000", ["Ethernet13/1", "Ethernet14/1"]),
            ("50000", ["Ethernet45/1", "Ethernet45/3", "Ethernet46/1", "Ethernet46/3"]),
            ("100000", ["Ethernet15/1", "Ethernet16/1"]),
            ("50000", ["Ethernet47/1", "Ethernet47/3", "Ethernet48/1", "Ethernet48/3"]),
            ("100000", ["Ethernet17/1", "Ethernet18/1"]),
            ("50000", ["Ethernet49/1", "Ethernet49/3", "Ethernet50/1", "Ethernet50/3"]),
            ("100000", ["Ethernet19/1", "Ethernet20/1"]),
            ("50000", ["Ethernet51/1", "Ethernet51/3", "Ethernet52/1", "Ethernet52/3"]),
            ("50000", ["Ethernet21/1", "Ethernet21/3", "Ethernet22/1", "Ethernet22/3", "Ethernet53/1", "Ethernet53/3",
                       "Ethernet54/1", "Ethernet54/3", "Ethernet23/1", "Ethernet23/3", "Ethernet24/1", "Ethernet24/3",
                       "Ethernet55/1", "Ethernet55/3", "Ethernet56/1", "Ethernet56/3", "Ethernet25/1", "Ethernet25/3",
                       "Ethernet26/1", "Ethernet26/3", "Ethernet57/1", "Ethernet57/3", "Ethernet58/1", "Ethernet58/3",
                       "Ethernet27/1", "Ethernet27/3", "Ethernet28/1", "Ethernet28/3", "Ethernet59/1", "Ethernet59/3",
                       "Ethernet60/1", "Ethernet60/3", "Ethernet29/1", "Ethernet29/3", "Ethernet30/1", "Ethernet30/3",
                       "Ethernet61/1", "Ethernet61/3", "Ethernet62/1", "Ethernet62/3", "Ethernet31/1", "Ethernet31/3",
                       "Ethernet32/1", "Ethernet32/3", "Ethernet63/1", "Ethernet63/3", "Ethernet64/1", "Ethernet64/3"]),
            ],
        "Cisco-8101-O32": [
            ("400000", ["etp{}".format(i) for i in range(32)]),
            ],
        "Cisco-8101-O8C48": [
            ("100000", ["etp{}{}".format(i // 2, "b" if i % 2 else "a") for i in range(24)]),
            ("400000", ["etp{}".format(i) for i in range(12, 20)]),
            ("100000", ["etp{}{}".format(i // 2, "b" if i % 2 else "a") for i in range(40, 64)]),
            ],
        "Cisco-8101-C64": [
            ("100000", ["etp{}{}".format(i // 2, chr(ord("a") + i % 2)) for i in range(64)]),
            ],
        "Cisco-8101-V64": [
            ("200000", ["etp{}{}".format(i // 2, chr(ord("a") + i % 2)) for i in range(64)]),
            ],
        "Arista-7050CX3-32S-C32": [
            ("100000", ["Ethernet{}/1".format(i + 1) for i in range(32)]),
            ],
        "Arista-7050CX3-32S-C16": [
            ("100000", ["Ethernet{}/1".format(i + 1) for i in range(16)]),
            ],
        "Arista-7050CX3-32S-S128": [
            ("10000", ["Ethernet{}/{}".format(i // 4 + 1, i % 4 + 1) for i in range(128)]),
            ],
        "Arista-7050CX3-32S-S64": [
            ("10000", ["Ethernet{}/{}".format(i // 4 + 1, i % 4 + 1) for i in range(64)]),
            ],
        "Arista-7050CX3-32S-D48C8": [
            ("50000", ["Ethernet{}/{}".format(i // 2 + 1, i % 2 * 2 + 1) for i in range(12)]),
            ("100000", ["Ethernet7/1", "Ethernet8/1", "Ethernet9/1", "Ethernet10/1"]),
            ("50000", ["Ethernet{}/{}".format(i // 2 + 11, i % 2 * 2 + 1) for i in range(24)]),
            ("100000", ["Ethernet23/1", "Ethernet24/1", "Ethernet25/1", "Ethernet26/1"]),
            ("50000", ["Ethernet{}/{}".format(i // 2 + 27, i % 2 * 2 + 1) for i in range(12)]),
            ],
        "Arista-7060CX-32S-C32": [
            ("100000", ["Ethernet{}/1".format(i + 1) for i in range(32)]),
            ],
        }


# 7260 is special because it is eos and hwsku does not follow the usual rule
# the recorded info for Arista-7260CX3 is really just for the C64
# 7060CX is similar in that it is also EOS
fanout_ports_info = {
        "Arista-7260CX3": {
            "100000": ["Ethernet{}/1".format(i // 4 * 2 + i % 4 % 2 + i % 4 // 2 * 32 + 1) for i in range(64)],
            "10000": ["Ethernet65", "Ethernet66"],
            },
        "Arista-7260CX3-dual-dut": {
            "100000": ["Ethernet{}/1".format(i + 1) for i in range(64)],
            "10000": ["Ethernet65", "Ethernet66"],
            },
        "Arista-7060CX-32S": {
            "100000": ["Ethernet{}/1".format(i + 1) for i in range(32)],
            "10000": ["Ethernet33", "Ethernet34"],
            },
        "Arista-7060CX-32S-S128": {
            "10000": ["Ethernet{}/{}".format(i // 4 + 1, i % 4 + 1) for i in range(128)] + ["Ethernet33", "Ethernet34"],
            },
        "Nokia-7215": {
            "1000": ["etp{}".format(i + 1) for i in range(48)],
            "10000": ["etp{}".format(i + 1) for i in range(48, 52)],
            },
        "Nokia-7215-A1": {
            "1000": ["etp{}".format(i + 1) for i in range(48)],
            "10000": ["etp{}".format(i + 1) for i in range(48, 52)],
            },
        "Arista-720DT-G48S4": {
            "1000": ["etp{}".format(i + 1) for i in range(48)],
            "10000": ["etp{}".format(i + 1) for i in range(48, 52)],
            },
        "Cisco-8101-O8C48": {
            "100000": ["etp{}{}".format(i // 2, "b" if i % 2 else "a") for i in list(range(24)) + list(range(40, 64))],
            "400000": ["etp{}".format(i) for i in range(12, 20)],
            },
        "Cisco-8101-O32": {
            "400000": ["etp{}".format(i) for i in range(0, 32)],
            },
        "Cisco-8101-V64": {
            "200000": ["etp{}{}".format(i // 2, chr(ord("a") + i % 2)) for i in range(64)],
            },
        "Cisco-8101-C64": {
            "100000": ["etp{}{}".format(i // 2, chr(ord("a") + i % 2)) for i in range(64)],
            },
        "Arista-7050CX3-32S-C32": {
            "100000": ["Ethernet{}/1".format(i + 1) for i in range(32)],
            },
        }


hwsku_logical_to_physical = {
        "Arista-7260CX3-D108C8": "Arista-7260CX3-C64",
        "Arista-7260CX3-D108C10": "Arista-7260CX3-C64",
        "Arista-7060CX-32S-D48C8": "Arista-7060CX-32S-C32",
        "Arista-7050CX3-32S-D48C8": "Arista-7050CX3-32S-C32",
        "Arista-7050CX3-32S-S128": "Arista-7050CX3-32S-C32",
        "Arista-7050CX3-32S-S64": "Arista-7050CX3-32S-C16",
        "Cisco-8101-O8C48": "Cisco-8101-O32",
        "Cisco-8101-V64": "Cisco-8101-O32",
        "Cisco-8101-C64": "Cisco-8101-O32",
        }


# TODO: consider when there is reduced speed
cable_map = {
        "1000-1000": "0.2 CAT6",
        "10000-10000": "10G DAC",
        "10000-100000": "10G DAC with 40G to 10G adapter",
        "100000-100000": "0.5 100G DAC",
        "400000-400000": "0.5 400G DAC",
        }


# get cable used between 2 ports
# should align with links csv, first should be either dut or root fanout
# second should be fanout or shared fanout
def get_cable(first_port_speed, second_port_speed=None):
    if not second_port_speed:
        second_port_speed = first_port_speed
    return cable_map["{}-{}".format(first_port_speed, second_port_speed)]


# some fanout has limitations, so we cannot simply use the last
# link of the dut, but need link with specific speed
special_hwsku_to_shared_fanout_speed = {
        "Cisco-8101-O8C48": "400000",
        }


# some fanouts have ports that exceed the ability of root fanout
# so their speed would need to be reduced
special_fanout_to_root_fanout_reduced_speed = {
        "Cisco-8101-O32": {"400000": "100000"},
        "Cisco-8101-O8C48": {"400000": "100000"},
        }


# some hwsku are made up and has no relevant reference in function
# in other package functions, so mark it here
special_hwsku_to_port_breakout_map = {
        "Arista-7050CX3-32S-S64": {"Ethernet{}/1".format(i + 1):
                                   ["Ethernet{}/{}".format(i + 1, j + 1) for j in range(4)] for i in range(16)},
        "Arista-7060CX-32S-S128": {"Ethernet{}/1".format(i + 1):
                                   ["Ethernet{}/{}".format(i + 1, j + 1) for j in range(4)] for i in range(32)},
        }


"""
Helpers
"""


def list_to_dict(header, *args):
    if len(header) != len(args):
        raise Exception("Header and args do not match: {} {}".format(header, args))
    return {field: args[i] for i, field in enumerate(header)}


def get_port_alias_to_name_map_wrapper(hwsku, convert=False, accept_special=False):
    if convert:
        hwsku = hwsku_logical_to_physical.get(hwsku, hwsku)
    if hwsku in ["Arista-7260CX3", "Arista-7260CX3-64", "Arista-7260CX3-dual-dut", "Arista-7060CX-32S"]:
        if accept_special:
            class KeyReturner:
                def __getitem__(self, key):
                    return key
            return KeyReturner()
        else:
            raise Exception("Special hwsku that should be handled otherwise")
    else:
        return get_port_alias_to_name_map(hwsku)[0]


def get_port_name_to_alias_map_wrapper(hwsku, convert=False):
    alias_to_name = get_port_alias_to_name_map_wrapper(hwsku, convert)
    name_to_alias = {}
    for key, value in alias_to_name.items():
        name_to_alias[value] = key
    return name_to_alias


def build_port_breakout_map(ports_physical, ports_logical):
    breakout_map = {}
    for port in ports_physical:
        breakout_ports = []
        for item in ports_logical:
            if item == port:
                breakout_ports.append(item)
            elif item.startswith(port) and item[len(port):].isalpha():
                breakout_ports.append(item)
            elif "/" in item and item[:item.find("/")] == port[:port.find("/")]:
                breakout_ports.append(item)
        breakout_map[port] = breakout_ports
    return breakout_map


def total_port_num_dut(dut_hwsku):
    return sum([len(ports) for _, ports in dut_ports_info[dut_hwsku]])


def get_port_breakout_map_7060(dut_hwsku_list):
    if len(dut_hwsku_list) != 1:
        raise Exception("Currently 1 7060 fanout cannot support all {} duts".format(dut_hwsku_list))
    dut_hwsku_logical = dut_hwsku_list[0]
    dut_port_num = total_port_num_dut(dut_hwsku_logical)
    if dut_port_num == 32:
        fanout_hwsku = "Arista-7060CX-32S-C32"
    elif dut_port_num == 56:
        fanout_hwsku = "Arista-7060CX-32S-D48C8"
    elif dut_port_num == 64:
        fanout_hwsku = "Arista-7060CX-32S-S128"
    else:
        raise Exception("Other dut hwsku have not been using Arista 7060 as fanout yet")
    port_breakout_map = get_port_breakout_map_generic(fanout_hwsku)
    port_breakout_map["Ethernet33"] = ["Ethernet33"]
    port_breakout_map["Ethernet34"] = ["Ethernet34"]
    return port_breakout_map


def get_port_breakout_map_7260(dut_hwsku_list):
    if len(dut_hwsku_list) == 1:
        dut_hwsku_logical = dut_hwsku_list[0]
        dut_port_num = total_port_num_dut(dut_hwsku_logical)
        if dut_port_num == 64:
            fanout_hwsku = "Arista-7260CX3-C64"
        elif dut_port_num == 120:
            fanout_hwsku = "Arista-7260CX3-D108C8"
        elif dut_port_num == 118:
            fanout_hwsku = "Arista-7260CX3-D108C10"
        else:
            raise Exception("Other dut hwsku have not been using Arista 7260 as fanout yet: "
                            "dut_hwsku_logical: {}, dut_port_num {}".format(dut_hwsku_logical, dut_port_num))
        port_breakout_map = get_port_breakout_map_generic(fanout_hwsku)
        port_breakout_map["Ethernet65"] = ["Ethernet65"]
        port_breakout_map["Ethernet66"] = ["Ethernet66"]
        return port_breakout_map
    elif len(dut_hwsku_list) == 2:
        port_breakout_map = get_port_breakout_map_7060([dut_hwsku_list[0]])
        port_breakout_map.pop("Ethernet33")
        port_breakout_map.pop("Ethernet34")

        def add_32_to_port(port):
            return re.sub(r"\d+", str(int(re.search(r"\d+", port).group()) + 32), port, count=1)

        for key, value in get_port_breakout_map_7060([dut_hwsku_list[1]]).items():
            port_breakout_map[add_32_to_port(key)] = list(map(lambda port: add_32_to_port(port), value))
        return port_breakout_map
    else:
        raise Exception("Currently 1 7260 fanout cannot support all {} duts".format(dut_hwsku_list))


def get_port_breakout_map_generic(hwsku):
    if hwsku in special_hwsku_to_port_breakout_map:
        return dict(special_hwsku_to_port_breakout_map[hwsku])
    ports_physical = get_port_alias_to_name_map_wrapper(hwsku, convert=True)
    ports_logical = get_port_alias_to_name_map_wrapper(hwsku, convert=False)
    return build_port_breakout_map(sorted(list(ports_physical.keys()), key=lambda port: port_cmp_key(port)),
                                   sorted(list(ports_logical.keys()), key=lambda port: port_cmp_key(port)))


# to make request of NUM physical ports with certain speed, we have to
# convert it to logical ports with certain speed so the correct ports
# from shared fanout can be allocated
def physical_ports_to_logical_ports(port_breakout_map, ports_physical):
    ret_value = []
    for port in ports_physical:
        ret_value.extend(port_breakout_map[port])
    return ret_value


def port_speed(ports_info, port):
    if isinstance(ports_info, dict):
        ports_info = ports_info.items()
    for speed, port_list in ports_info:
        if port in port_list:
            return speed


# Used to compare port
# Currently supports EthernetN, EthernetN/M, etpN, etpN{a-d} styles of port name
def port_cmp_key(port):
    if port.startswith("Empty"):
        port = port[5:]
    if port.startswith("Ethernet"):
        port = port[8:]
    if port.startswith("etp"):
        port = port[3:]
    items = port.split("/")
    if len(items) == 1:
        item = items[0]
        if item.isdigit():
            return int(item)
        elif item[:-1].isdigit() and item[-1:].isalpha():
            return int(item[:-1]) + int(ord(item[-1:]) - 96) / 16
    if len(items) == 2:
        return int(items[0]) + int(items[1]) / 16


def device_cmp_key(device_name):
    ret = device_name.rsplit("-", 1)
    ret[1] = int(ret[1])
    return ret


# vlan ids are assumed to be increasing
# if not, should sort first
def gen_trunk_vlan(links, fanout_name):
    start_vlan = -1
    curr_vlan = -1
    intervals = []
    for vlan in map(lambda link: int(link["VlanID"]), filter(lambda link: link["EndDevice"] == fanout_name, links)):
        if vlan - curr_vlan > 1:
            if start_vlan == curr_vlan:
                intervals.append("{}".format(curr_vlan))
            else:
                intervals.append("{}-{}".format(start_vlan, curr_vlan))
            start_vlan = vlan
        elif vlan - curr_vlan < 1:
            raise Exception("Input vlan id to gen_trunk_vlan is expected to increase")
        curr_vlan = vlan
    if start_vlan == curr_vlan:
        intervals.append("{}".format(curr_vlan))
    else:
        intervals.append("{}-{}".format(start_vlan, curr_vlan))
    return ",".join(intervals[1:])


# assume no overlap with vlan id
def combine_trunk_vlan(trunk_vlans):
    intervals = []
    for trunk_vlan in trunk_vlans:
        trunk_vlan = trunk_vlan.strip("\"")
        if trunk_vlan:
            intervals.extend(trunk_vlan.split(","))
    intervals = sorted(intervals, key=lambda interval: int(interval.split("-")[0]))
    start_vlan = -1
    curr_vlan = -1
    combined_intervals = []
    for interval in intervals:
        items = interval.split("-")
        if len(items) == 1 or len(items) == 2:
            vlan = int(items[0])
            if vlan - curr_vlan > 1:
                if start_vlan == curr_vlan:
                    combined_intervals.append("{}".format(curr_vlan))
                else:
                    combined_intervals.append("{}-{}".format(start_vlan, curr_vlan))
                start_vlan = vlan
            elif vlan - curr_vlan < 1:
                raise Exception("Input vlan id should have no overlap")
            curr_vlan = int(items[-1])
        else:
            raise Exception("Trunk vlan {} is not legal".format(interval))
    if start_vlan == curr_vlan:
        combined_intervals.append("{}".format(curr_vlan))
    else:
        combined_intervals.append("{}-{}".format(start_vlan, curr_vlan))
    return "{}".format(",".join(combined_intervals[1:]))


def link_split(link):
    items = link.split(",")
    ret_value = []
    in_quote = False
    for item in items:
        if in_quote:
            ret_value[-1] = ret_value[-1] + "," + item
            if item.endswith("\""):
                in_quote = False
        else:
            ret_value.append(item)
            if item.startswith("\"") and not item.endswith("\""):
                in_quote = True
    return ret_value


class BreakoutPorts(ABC):

    # for 7260 hwsku, speed is required to correctly removing port,
    # but for fix speed hwsku, speed is not
    # so we check for speed if it is provided, but it is also fine if
    # it is not
    # since remove_port is only for filtering out occupied ports and
    # links.csv only records logical ports and links, remove_port
    # accepts only logical ports
    @abstractmethod
    def remove_port(self, port, speed):
        pass

    # pop_port accepts both logical port and speed request and
    # return 3 items, physical port speed, logical port speed, a physical port
    # to logical port mapping
    # no_breakout disallows breakout ports, which is only used for non sonic
    # speed_physical and num_physical can be provided to aid in result
    @abstractmethod
    def pop_port(self, speed, num, extra_vars={}):
        pass

    # return alias to sonic name mapping
    @abstractmethod
    def alias_to_name_map(self):
        pass

    @abstractmethod
    def port_speed(self, port):
        pass


class BreakoutPortsEmpty(BreakoutPorts):

    def remove_port(self, port, speed):
        raise Exception("Did not expcet remove_port of BreakoutPortsEmpty to be called")

    # with this case, just fabricate any result that suits the need
    def pop_port(self, speed, num, extra_vars={}):
        if "speed_physical" in extra_vars and "num_physical" in extra_vars:
            return extra_vars["speed_physical"], speed, \
                   {"Empty{}".format(i): ["Empty{}{}".format(i, chr(ord("a") + j))
                                          for j in range(num // extra_vars["num_physical"])]
                    for i in range(extra_vars["num_physical"])}
        else:
            return speed, speed, {"Empty{}".format(i): ["Empty{}".format(i)] for i in range(num)}

    def alias_to_name_map(self):
        raise Exception("Did not expcet alias_to_name_map of BreakoutPortsEmpty to be called")

    def port_speed(self, port):
        raise Exception("Did not expect port_speed of BreakoutPortsEmpty to be called")


class BreakoutPortsBasic(BreakoutPorts):

    def __init__(self, hwsku=None):
        self.hwsku = hwsku
        if hwsku is not None:
            self.ports = {k: v[:] for k, v in fanout_ports_info[hwsku].items()}
            self.name_to_alias_map = get_port_name_to_alias_map_wrapper(hwsku)

    def remove_port(self, port, speed=None):
        if self.hwsku is None:
            raise Exception("Empty BreakoutPorts object should not be called")
        port = self.name_to_alias_map.get(port, port)
        if speed:
            if speed not in self.ports:
                raise Exception("{} does not have port {} with speed {}".format(self.hwsku, port, speed))
            self.ports[speed].remove(port)
        else:
            for _, port_list in self.ports.items():
                if port in port_list:
                    port_list.remove(port)
                    return
            raise Exception("Port {} does not exist or has already been removed".format(port))

    def pop_port(self, speed, num, extra_vars={}):
        if self.hwsku is None:
            raise Exception("Empty BreakoutPorts object should not be called")
        if speed not in self.ports:
            raise Exception("{} does not have {} port with speed {}".format(self.hwsku, num, speed))
        ret_ports = self.ports[speed][:num]
        self.ports[speed] = self.ports[speed][num:]
        ret_value = {}
        for port in ret_ports:
            ret_value[port] = [port]
        return speed, speed, ret_value

    def alias_to_name_map(self):
        return get_port_alias_to_name_map_wrapper(self.hwsku)

    def port_speed(self, port):
        return port_speed(fanout_ports_info[self.hwsku], port)


class BreakoutPortsGeneric(BreakoutPorts):

    def __init__(self, hwsku_logical, hwsku_physical):
        self.breakout_ports_logical = BreakoutPortsBasic(hwsku_logical)
        self.breakout_ports_physical = BreakoutPortsBasic(hwsku_physical)
        self.port_breakout_map = get_port_breakout_map_generic(hwsku_logical)

    def remove_port(self, port, speed):
        self.breakout_ports_logical.remove_port(port, speed)
        try:
            for port_physical, ports_logical in self.port_breakout_map.items():
                if port in ports_logical:
                    self.breakout_ports_physical.remove_port(port_physical, None)
        except:  # noqa E722
            pass

    def pop_port(self, speed, num, extra_vars={}):
        _, speed_logical, ret_ports_logical = self.breakout_ports_logical.pop_port(speed, num)
        ret_value = {}
        for port_logical in ret_ports_logical:
            for port_physical, ports_logical in self.port_breakout_map.items():
                if port_logical in ports_logical:
                    speed_physical = self.breakout_ports_physical.port_speed(port_physical)
                    ret_value[port_physical] = ret_value.get(port_physical, []) + [port_logical]
        for port_physical in ret_value.keys():
            self.breakout_ports_physical.remove_port(port_physical, None)
        return speed_physical, speed_logical, ret_value

    # there shouldn't be one alias to different sonic name, the reverse is not true
    def alias_to_name_map(self):
        return self.breakout_ports_physical.alias_to_name_map().update(self.breakout_ports_logical.alias_to_name_map())

    def port_speed(self, port):
        return self.breakout_ports_logical.port_speed(port)


class BreakoutPortsArista(BreakoutPorts):

    @abstractmethod
    def __init__(self):
        pass

    def __breakout_to_10G(self, ports_100G):
        for port_100G in ports_100G:
            self.ports["100000"].remove(port_100G)
        self.ports["10000"].extend([port[:-1] + "{}".format(i + 1) for i in range(4) for port in ports_100G])

    def __breakout_to_50G(self, ports_100G):
        for port_100G in ports_100G:
            self.ports["100000"].remove(port_100G)
        self.ports["50000"].extend([port[:-1] + "{}".format(i) for i in [1, 3] for port in ports_100G])

    def remove_port(self, port, speed):
        if speed == "100000" or speed == "40000":
            self.ports["100000"].remove(port)
        elif speed == "50000":
            if port in self.ports["50000"]:
                self.ports["50000"].remove(port)
            elif port[:-1] + "1" in self.ports["100000"]:
                self.__breakout_to_50G([port[:-1] + "1"])
                self.ports["50000"].remove(port)
            else:
                raise Exception("Port {} with speed {} is illegal".format(port, speed))
        elif speed == "10000":
            if port in self.ports["10000"]:
                self.ports["10000"].remove(port)
            elif port in self.ports["10000*"]:
                self.ports["10000*"].remove(port)
            elif port[:-1] + "1" in self.ports["100000"]:
                self.__breakout_to_10G([port[:-1] + "1"])
                self.ports["10000"].remove(port)
            else:
                raise Exception("Port {} with speed {} is illegal".format(port, speed))
        else:
            raise Exception("Port {} with speed {} is illegal".format(port, speed))

    def pop_port(self, speed, num, extra_vars={}):
        if speed == "100000" or speed == "40000":
            if len(self.ports["100000"]) < num:
                raise Exception("Not enough ports available with speed {}".format(speed))
            ret_ports = self.ports["100000"][:num]
            self.ports["100000"] = self.ports["100000"][num:]
        elif speed == "50000":
            num_100G = min(len(self.ports["100000"]), num // 2)
            ret_ports.extend([port[:-1] + "{}".format(i) for i in [1, 3] for port in self.ports["100000"][:num_100G]])
            self.ports["100000"] = self.ports["100000"][num_100G:]
            num_50G = num - num_100G * 2
            if num_50G > len(self.ports["50000"]):
                num_100G_to_50G = (num_50G - len(self.ports["50000"]) - 1) // 2 + 1
                self.__breakout_to_50G(self.ports["100000"][:num_100G_to_50G])
            ret_ports.extend(self.ports["50000"][:num_50G])
            self.ports["50000"] = self.ports["50000"][num_50G:]
        elif speed == "10000":
            if "no_breakout" in extra_vars and extra_vars["no_breakout"] is True:
                return self.pop_port("100000", num)
            if len(self.ports["100000"]) * 4 + len(self.ports["10000"]) + len(self.ports["10000*"]) < num:
                raise Exception("Not enough ports available with speed {}".format(speed))
            # first check if we will use the low priority ports
            ret_ports = []
            num_low_pri = max(num - len(self.ports["100000"]) * 4 - len(self.ports["10000"]), 0)
            if num_low_pri > 0:
                self.ports["10000"].extend(self.ports["10000*"][:num_low_pri])
                self.ports["10000*"] = self.ports["10000*"][num_low_pri:]
            # first pick out all 100G ports
            num_100G = min(len(self.ports["100000"]), num // 4)
            ret_ports.extend([port[:-1] + "{}".format(i + 1) for i in range(4)
                              for port in self.ports["100000"][:num_100G]])
            self.ports["100000"] = self.ports["100000"][num_100G:]
            num_10G = num - num_100G * 4
            if num_10G > len(self.ports["10000"]):
                num_100G_to_10G = (num_10G - len(self.ports["10000"]) - 1) // 4 + 1
                self.__breakout_to_10G(self.ports["100000"][:num_100G_to_10G])
            ret_ports.extend(self.ports["10000"][:num_10G])
            self.ports["10000"] = self.ports["10000"][num_10G:]
        else:
            raise Exception("Speed {} is not supported".format(speed))
        ret_value = {}
        for port in ret_ports:
            ret_value[port] = [port]
        return speed, speed, ret_value

    def alias_to_name_map(self):
        return get_port_alias_to_name_map_wrapper(self.hwsku, accept_special=True)

    # Arista ports can be breakout to 4, and EthernetN/1 can be either 1 of 4 or
    # the whole port. This is a problem with current links recording system. We
    # assume for now EthernetN/1 is 1 of 4 to save resource. However for the purpose
    # of less confusion, this method should not be valid
    def port_speed(self, port):
        raise Exception("Arista device has ambiguity with its port name")


class BreakoutPortsArista7260CX3(BreakoutPortsArista):

    def __init__(self):
        # speed 10000* is lower priority
        self.hwsku = "Arista-7260CX3"
        self.ports = {
                "100000": ["Ethernet{}/1".format(i + 1) for i in range(64)],
                "50000": [],
                "10000": [],
                "10000*": ["Ethernet65", "Ethernet66"],
                }


class BreakoutPortsArista7060CX(BreakoutPortsArista):

    def __init__(self):
        self.hwsku = "Arista-7060CX-32S"
        self.ports = {
                "100000": ["Ethernet{}/1".format(i + 1) for i in range(32)],
                "50000": [],
                "10000": [],
                "10000*": ["Ethernet33", "Ethernet34"],
                }


def get_breakout_ports(hwsku=None):
    if hwsku is None:
        return BreakoutPortsBasic(None)
    if hwsku == "empty":
        return BreakoutPortsEmpty()
    if hwsku == "Arista-7260CX3" or hwsku == "Arista-7260CX3-64":
        return BreakoutPortsArista7260CX3()
    if hwsku == "Arista-7060CX-32S":
        return BreakoutPortsArista7060CX()
    if hwsku in fanout_ports_info:
        if hwsku in hwsku_logical_to_physical:
            return BreakoutPortsGeneric(hwsku, hwsku_logical_to_physical[hwsku])
        else:
            return BreakoutPortsBasic(hwsku)
    raise Exception("{} is not supported as breakout ports".format(hwsku))


def get_physical_ports_from_generator(generator, speed, num):
    speed_physical, _, port_breakout_map = generator(speed, num)
    return speed_physical, sorted(port_breakout_map.keys(), key=lambda port: port_cmp_key(port))


def get_logical_ports_from_generator(generator, speed, num):
    _, speed_logical, port_breakout_map = generator(speed, num)
    list_sum = []
    for ports_logical in port_breakout_map.values():
        list_sum.extend(ports_logical)
    return speed_logical, sorted(list_sum, key=lambda port: port_cmp_key(port))


"""
Implementation. The script will generate the physical links first and then
generate the matching logical links based on the physical links. Basically,
it assumes when physical ports and speed match, logical ports and speed will
also match. It is not guaranteed to be true. It in fact is a problem with
shared fanout port allocation because for shared fanouts, physical ports and
speed can match but logical ports and speed are not.
"""


class Device:
    def __init__(self, name, hwsku):
        self.name = name
        self.hwsku = hwsku
        self.hwsku_physical = hwsku_logical_to_physical.get(hwsku, hwsku)

    def init_dut(self):
        self.ports_logical = dut_ports_info[self.hwsku]
        self.ports_physical = dut_ports_info[self.hwsku_physical]
        self.port_breakout_map = get_port_breakout_map_generic(self.hwsku)
        self.alias_to_name_map = get_port_alias_to_name_map_wrapper(self.hwsku, convert=False, accept_special=False)
        self.alias_to_name_map_physical = get_port_alias_to_name_map_wrapper(self.hwsku, convert=True,
                                                                             accept_special=False)

    def init_fanout(self, dut_hwsku_list=None):
        hwsku = "Arista-7260CX3-dual-dut" if self.hwsku == "Arista-7260CX3" and len(dut_hwsku_list) == 2 else self.hwsku
        hwsku_physical = hwsku_logical_to_physical.get(hwsku, hwsku)
        self.ports_logical = fanout_ports_info[hwsku]
        self.ports_physical = fanout_ports_info[hwsku_physical]
        # for most hwsku, fanout hwsku decides what its port mapping looks like,
        # but for Arista 7260, it's port breakout depends on the dut
        if self.hwsku in ["Arista-7260CX3", "Arista-7260CX3-64", "Arista-7260CX3-dual-dut"]:
            self.port_breakout_map = get_port_breakout_map_7260(dut_hwsku_list)
        elif self.hwsku == "Arista-7060CX-32S":
            self.port_breakout_map = get_port_breakout_map_7060(dut_hwsku_list)
        else:
            self.port_breakout_map = get_port_breakout_map_generic(self.hwsku)
        self.alias_to_name_map = get_port_alias_to_name_map_wrapper(self.hwsku, convert=False, accept_special=True)
        self.alias_to_name_map_physical = get_port_alias_to_name_map_wrapper(self.hwsku, convert=True,
                                                                             accept_special=True)

    def num_speed(self, physical=False):
        return len(self.ports_physical) if physical else len(self.ports_logical)

    def speed(self, physical=False):
        ports = self.ports_physical if physical else self.ports_logical
        if isinstance(ports, dict):
            ports = ports.items()
        return map(lambda item: item[0], ports)

    def port_list(self, speed, physical=False):
        ports = self.ports_physical if physical else self.ports_logical
        if isinstance(ports, dict):
            ports = ports.items()
        return filter(lambda item: item[0] == speed, ports).__next__()[1]

    def port_speed(self, port, physical=False):
        ports = self.ports_physical if physical else self.ports_logical
        return port_speed(ports, port)

    def port_breakouts(self, port):
        return len(self.port_breakout_map[port]) != 1

    def alias_to_name(self, port, physical=False):
        if physical:
            return self.alias_to_name_map_physical[port]
        else:
            return self.alias_to_name_map[port]

    def __eq__(self, other):
        return self.name == other.name


class GenLink:
    def __init__(self):
        self.__duts = []
        self.__fanouts = []
        self.__physical_links = []
        self.__logical_links = []
        self.__root_fanout_link_physical = []
        self.__root_fanout_link_logical = []
        self.__shared_fanout_port_breakout_map = {}

    def contains_dut(self, dut_name):
        return any(map(lambda dut: dut.name == dut_name, self.__duts))

    def contains_fanout(self, fanout_name):
        return any(map(lambda fanout: fanout.name == fanout_name, self.__fanouts))

    def add_dut(self, dut_name, dut_hwsku):
        if not self.contains_dut(dut_name):
            dut = Device(dut_name, dut_hwsku)
            self.__duts.append(dut)

    def __dut_hwsku(self):
        return map(lambda dut: dut.hwsku, self.__duts)

    def add_fanout(self, fanout_name, fanout_hwsku):
        if not self.contains_fanout(fanout_name):
            fanout = Device(fanout_name, fanout_hwsku)
            self.__fanouts.append(fanout)

    def init_devices(self):
        for dut in self.__duts:
            dut.init_dut()
        for fanout in self.__fanouts:
            fanout.init_fanout(list(self.__dut_hwsku()))

    def __find_device(self, device_name, devices):
        return filter(lambda device: device.name == device_name, devices).__next__()

    def find_dut(self, dut_name):
        return self.__find_device(dut_name, self.__duts)

    def find_fanout(self, fanout_name):
        return self.__find_device(fanout_name, self.__fanouts)

    # fanout / shared fanout side port might need to reduce its port speed to match with root fanout port
    def __reduce_speed_for_root_fanout(self, fanout, speed):
        return special_fanout_to_root_fanout_reduced_speed.get(fanout.hwsku_physical, {speed: speed}).get(speed, speed)

    def __match_logical_shared_fanout_speed(self, dut, dut_port_physical):
        if dut.hwsku in special_hwsku_to_shared_fanout_speed:
            required_speed_by_shared_fanout = special_hwsku_to_shared_fanout_speed[dut.hwsku]
            qualified_ports_logical = filter(lambda item: item[0] == required_speed_by_shared_fanout,
                                             dut.ports_logical).__next__()[1]
            return all(map(lambda port_logical: port_logical in qualified_ports_logical,
                           dut.port_breakout_map[dut_port_physical]))
        else:
            return True

    def __get_shared_fanout_port_list_physical(self, dut, dut_port_list_for_shared_fanout_physical,
                                               shared_fanout_port_generator, extra_vars={}):
        dut_port_list_for_shared_fanout_logical = physical_ports_to_logical_ports(
                dut.port_breakout_map,
                dut_port_list_for_shared_fanout_physical)
        dut_speed_logical = dut.port_speed(dut_port_list_for_shared_fanout_logical[0])
        if not all(map(lambda port: dut.port_speed(port) == dut_speed_logical,
                       dut_port_list_for_shared_fanout_logical)):
            raise Exception("Logical ports {} do not have the same speed".
                            format(dut_port_list_for_shared_fanout_logical))
        shared_fanout_speed_physical, shared_fanout_speed_logical, shared_fanout_port_breakout_map = \
            shared_fanout_port_generator(dut_speed_logical, len(dut_port_list_for_shared_fanout_logical),
                                         {"num_physical": len(dut_port_list_for_shared_fanout_physical),
                                          **extra_vars})
        self.__shared_fanout_port_breakout_map.update(shared_fanout_port_breakout_map)
        shared_fanout_port_list_physical = []
        for port_physical, ports_logical in shared_fanout_port_breakout_map.items():
            shared_fanout_port_list_physical.append(port_physical)
        return shared_fanout_speed_physical, sorted(shared_fanout_port_list_physical,
                                                    key=lambda port: port_cmp_key(port))

    def __gen_physical_link_no_fanout(self, dut, root_fanout_name, root_fanout_port_generator,
                                      shared_fanout_name, shared_fanout_port_generator):
        speed = dut.speed(physical=True).__next__()
        dut_port_list = dut.port_list(speed, physical=True)
        shared_fanout_port_speed, shared_fanout_port_list = \
            self.__get_shared_fanout_port_list_physical(dut, dut_port_list, shared_fanout_port_generator)
        for i in range(len(dut_port_list)):
            self.__physical_links.append(list_to_dict(physical_links_header,
                                                      dut.name, dut_port_list[i], shared_fanout_name,
                                                      shared_fanout_port_list[i], speed,
                                                      get_cable(speed, shared_fanout_port_speed)))

    # for m0/mx we assume there will be no port breakout
    def __gen_physical_link_m0_mx(self, dut, fanout, root_fanout_name, root_fanout_port_generator, shared_fanout_name,
                                  shared_fanout_port_generator, m0_pattern="2"):
        speeds = dut.speed(physical=True)
        speed = speeds.__next__()
        dut_port_list = dut.port_list(speed)
        fanout_port_list = fanout.port_list(speed)
        dut_port_num = len(dut_port_list)
        fanout_port_num = len(fanout_port_list)
        if dut_port_num > fanout_port_num:
            raise Exception("Fanout {} does not have enough ports with speed {}".format(fanout.name, speed))
        for i in range(dut_port_num):
            self.__physical_links.append(list_to_dict(physical_links_header,
                                                      dut.name, dut_port_list[i], fanout.name, fanout_port_list[i],
                                                      speed, get_cable(speed)))
        speed = speeds.__next__()
        dut_port_list = dut.port_list(speed)
        fanout_port_list = fanout.port_list(speed)
        dut_port_num = len(dut_port_list)
        fanout_port_num = len(fanout_port_list)
        reduced_speed = self.__reduce_speed_for_root_fanout(fanout, speed)
        if m0_pattern == "1":
            if dut_port_num > fanout_port_num:
                raise Exception("Fanout {} does not have enough ports with speed {}".format(fanout.name, speed))
            for i in range(dut_port_num - 1):
                self.__physical_links.append(list_to_dict(physical_links_header,
                                                          dut.name, dut_port_list[i], fanout.name, fanout_port_list[i],
                                                          speed, get_cable(speed)))
            shared_fanout_port_speed, shared_fanout_port_list = \
                self.__get_shared_fanout_port_list_physical(dut, dut_port_list[-1:],
                                                            shared_fanout_port_generator)
            self.__physical_links.append(list_to_dict(physical_links_header,
                                                      dut.name, dut_port_list[dut_port_num - 1],
                                                      shared_fanout_name, shared_fanout_port_list[0], speed,
                                                      get_cable(speed, shared_fanout_port_speed)))
            root_fanout_port_speed, root_fanout_port_list = \
                get_physical_ports_from_generator(root_fanout_port_generator, reduced_speed, 1)
            self.__root_fanout_link_physical.append(list_to_dict(physical_links_header,
                                                                 root_fanout_name, root_fanout_port_list[0],
                                                                 fanout.name, fanout_port_list[dut_port_num - 1],
                                                                 speed, get_cable(root_fanout_port_speed, speed)))
        elif m0_pattern == "2" or m0_pattern == "3":
            shared_fanout_port_speed, shared_fanout_port_list = \
                    self.__get_shared_fanout_port_list_physical(dut, dut_port_list, shared_fanout_port_generator,
                                                                extra_vars={"no_breakout": m0_pattern == "3"})
            shared_fanout_port_num = len(dut_port_list)
            for i in range(shared_fanout_port_num):
                self.__physical_links.append(list_to_dict(physical_links_header,
                                                          dut.name, dut_port_list[i], shared_fanout_name,
                                                          shared_fanout_port_list[i], speed,
                                                          get_cable(speed, shared_fanout_port_speed)))
            root_fanout_port_speed, root_fanout_port_list = \
                get_physical_ports_from_generator(root_fanout_port_generator, reduced_speed, 1)
            self.__root_fanout_link_physical.append(list_to_dict(physical_links_header,
                                                                 root_fanout_name, root_fanout_port_list[0],
                                                                 fanout.name, fanout_port_list[0], reduced_speed,
                                                                 get_cable(root_fanout_port_speed, reduced_speed)))
        else:
            raise Exception("Pattern {} is not known".format(m0_pattern))

    def __gen_physical_link_not_m0_mx_single_speed_fanout(self, dut, fanout, root_fanout_name,
                                                          root_fanout_port_generator, shared_fanout_name,
                                                          shared_fanout_port_generator):
        speed = dut.speed(physical=True).__next__()
        dut_port_list = dut.port_list(speed, physical=True)
        fanout_port_list = fanout.port_list(speed, physical=True)
        dut_port_num = len(dut_port_list)
        fanout_port_num = len(fanout_port_list)
        reduced_speed = self.__reduce_speed_for_root_fanout(fanout, speed)
        # dut has less ports than fanout
        # no shared fanout needed
        if dut_port_num < fanout_port_num:
            for i in range(dut_port_num):
                self.__physical_links.append(list_to_dict(physical_links_header,
                                                          dut.name, dut_port_list[i], fanout.name,
                                                          fanout_port_list[i], speed, get_cable(speed)))
            root_fanout_port_speed, root_fanout_port_list = \
                get_physical_ports_from_generator(root_fanout_port_generator, reduced_speed, 1)
            self.__root_fanout_link_physical.append(list_to_dict(physical_links_header,
                                                                 root_fanout_name, root_fanout_port_list[0],
                                                                 fanout.name, fanout_port_list[dut_port_num],
                                                                 reduced_speed,
                                                                 get_cable(root_fanout_port_speed, reduced_speed)))
        # fanout ports are not enough, need another shared fanout
        elif dut_port_num >= fanout_port_num:
            to_fanout_link_num = fanout_port_num - 1
            to_shared_fanout_link_num = dut_port_num - to_fanout_link_num
            # we assume shared fanout would be the last few links, unless specified otherwise
            # and if we pick from middle to connect to shared fanout, we skip a port for fanout too
            qualified_port_list = dut_port_list
            if dut.hwsku in special_hwsku_to_shared_fanout_speed:
                dut_port_list_to_shared_fanout = []
                qualified_port_list = list(filter(lambda port: self.__match_logical_shared_fanout_speed(dut, port),
                                                  dut_port_list))
            dut_port_list_to_shared_fanout = qualified_port_list[-to_shared_fanout_link_num:]
            shared_fanout_port_speed, shared_fanout_port_list = \
                self.__get_shared_fanout_port_list_physical(dut, dut_port_list_to_shared_fanout,
                                                            shared_fanout_port_generator,
                                                            extra_vars={"speed_physical": speed})
            shared_fanout_port_index = 0
            last_unused_fanout_port = None
            for i in range(dut_port_num):
                dut_port = dut_port_list[i]
                if dut_port in dut_port_list_to_shared_fanout:
                    self.__physical_links.append(list_to_dict(physical_links_header,
                                                              dut.name, dut_port, shared_fanout_name,
                                                              shared_fanout_port_list[shared_fanout_port_index],
                                                              speed, get_cable(speed, shared_fanout_port_speed)))
                    shared_fanout_port_index = shared_fanout_port_index + 1
                    last_unused_fanout_port = fanout_port_list[i]
                else:
                    self.__physical_links.append(list_to_dict(physical_links_header,
                                                              dut.name, dut_port, fanout.name, fanout_port_list[i],
                                                              speed, get_cable(speed)))
            root_fanout_port_speed, root_fanout_port_list = \
                get_physical_ports_from_generator(root_fanout_port_generator, reduced_speed, 1)
            if last_unused_fanout_port:
                self.__root_fanout_link_physical.append(list_to_dict(physical_links_header,
                                                                     root_fanout_name, root_fanout_port_list[0],
                                                                     fanout.name, last_unused_fanout_port,
                                                                     reduced_speed, get_cable(root_fanout_port_speed,
                                                                                              reduced_speed)))
            else:
                self.__root_fanout_link_physical.append(list_to_dict(physical_links_header,
                                                                     root_fanout_name, root_fanout_port_list[0],
                                                                     fanout.name, fanout_port_list[fanout_port_num - 1],
                                                                     reduced_speed,
                                                                     get_cable(root_fanout_port_speed, reduced_speed)))

    def __gen_physical_link_not_m0_mx_dual_speed_fanout(self, dut, fanout, root_fanout_name,
                                                        root_fanout_port_generator):
        speed = dut.speed(physical=True).__next__()
        dut_port_list = dut.port_list(speed, physical=True)
        dut_port_num = len(dut_port_list)
        fanout_port_list = fanout.port_list(speed, physical=True)
        fanout_port_num = len(fanout_port_list)
        if fanout_port_num < dut_port_num:
            raise Exception("Fanout should have no less same speed ports than dut: {} {}".
                            format(fanout_port_num, dut_port_num))
        for i in range(dut_port_num):
            self.__physical_links.append(list_to_dict(physical_links_header,
                                                      dut.name, dut_port_list[i], fanout.name,
                                                      fanout_port_list[i], speed, get_cable(speed)))
        second_speed = filter(lambda item: item != speed, fanout.speed()).__next__()
        fanout_port_list = fanout.port_list(second_speed, physical=True)
        reduced_speed = self.__reduce_speed_for_root_fanout(fanout, second_speed)
        root_fanout_port_speed, root_fanout_port_list = \
            get_physical_ports_from_generator(root_fanout_port_generator, reduced_speed, 1)
        self.__root_fanout_link_physical.append(list_to_dict(physical_links_header,
                                                             root_fanout_name, root_fanout_port_list[0],
                                                             fanout.name, fanout_port_list[0], reduced_speed,
                                                             get_cable(root_fanout_port_speed, reduced_speed)))

    def __gen_physical_link_dual_dut_dual_speed_fanout(self, duts, fanout, root_fanout_name,
                                                       root_fanout_port_generator):
        speed = duts[0].speed(physical=True).__next__()
        dut_port_lists = list(map(lambda dut: dut.port_list(speed, physical=True), duts))
        dut_port_nums = list(map(lambda item: len(item), dut_port_lists))
        fanout_port_list = fanout.port_list(speed, physical=True)
        fanout_port_num = len(fanout_port_list)
        if fanout_port_num < sum(dut_port_nums):
            raise Exception("Fanout should have no less same speed ports than duts: {} {}"
                            .format(fanout_port_num, sum(dut_port_nums)))
        for i, dut_port_list in enumerate(dut_port_lists):
            for j, dut_port in enumerate(dut_port_list):
                self.__physical_links.append(list_to_dict(physical_links_header,
                                                          duts[i].name, dut_port, fanout.name,
                                                          fanout_port_list[sum(dut_port_nums[:i]) + j],
                                                          speed, get_cable(speed)))
        second_speed = filter(lambda item: item != speed, fanout.speed()).__next__()
        fanout_port_list = fanout.port_list(second_speed, physical=True)
        reduced_speed = self.__reduce_speed_for_root_fanout(fanout, second_speed)
        root_fanout_port_speed, root_fanout_port_list = \
            get_physical_ports_from_generator(root_fanout_port_generator, reduced_speed, 1)
        self.__root_fanout_link_physical.append(list_to_dict(physical_links_header,
                                                             root_fanout_name, root_fanout_port_list[0],
                                                             fanout.name, fanout_port_list[0], reduced_speed,
                                                             get_cable(root_fanout_port_speed, reduced_speed)))

    def gen_physical_link(self, root_fanout_name, root_fanout_port_generator, shared_fanout_name,
                          shared_fanout_port_generator, m0_pattern="2"):
        if self.__physical_links:
            return
        if len(self.__duts) == 1 and len(self.__fanouts) == 1:
            dut = self.__duts[0]
            fanout = self.__fanouts[0]
            if dut.num_speed(physical=True) == 1 and fanout.num_speed(physical=True) == 1:
                self.__gen_physical_link_not_m0_mx_single_speed_fanout(dut, fanout, root_fanout_name,
                                                                       root_fanout_port_generator, shared_fanout_name,
                                                                       shared_fanout_port_generator)
            elif dut.num_speed(physical=True) == 1 and fanout.num_speed(physical=True) == 2:
                self.__gen_physical_link_not_m0_mx_dual_speed_fanout(dut, fanout, root_fanout_name,
                                                                     root_fanout_port_generator)
            elif dut.num_speed(physical=True) == 2 and fanout.num_speed(physical=True) == 2:
                self.__gen_physical_link_m0_mx(dut, fanout, root_fanout_name, root_fanout_port_generator,
                                               shared_fanout_name, shared_fanout_port_generator, m0_pattern)
            else:
                raise Exception("Does not support dut and fanout like this: {}, {}".format(dut.name, fanout.name))
        elif len(self.__duts) == 2 and len(self.__fanouts) == 1:
            if not all(map(lambda dut: dut.num_speed(physical=True) == 1, self.__duts)):
                raise Exception("If there are multiple duts to 1 fanout, duts can only have 1 speed")
            fanout = self.__fanouts[0]
            if fanout.num_speed(physical=True) == 1:
                raise Exception("Not implemented yet")
            elif fanout.num_speed(physical=True) == 2:
                self.__gen_physical_link_dual_dut_dual_speed_fanout(self.__duts, fanout, root_fanout_name,
                                                                    root_fanout_port_generator)
            else:
                raise Exception("Does not support fanout like this: {}".format(fanout.name))
        elif len(self.__duts) == 1 and len(self.__fanouts) == 0:
            dut = self.__duts[0]
            if dut.num_speed(physical=True) == 1:
                self.__gen_physical_link_no_fanout(dut, root_fanout_name, root_fanout_port_generator,
                                                   shared_fanout_name, shared_fanout_port_generator)
            else:
                raise Exception("If no fanout is provided, dut cannot have more than 1 speed")
        else:
            raise Exception("Combo of {} duts and {} fanouts is not supported"
                            .format(len(self.__duts), len(self.__fanouts)))
        self.__physical_links = sorted(self.__physical_links,
                                       key=lambda link: (device_cmp_key(link["StartDevice"]),
                                                         port_cmp_key(link["StartPort"])))

    def gen_logical_link(self, starting_vlan):
        if not self.__physical_links:
            raise Exception("Physical link should be generated before logical link")
        logical_links = []
        for physical_link in self.__physical_links:
            logical_link = dict(physical_link)
            del logical_link["Cable"]
            dut = self.find_dut(logical_link["StartDevice"])
            dut_ports_logical = dut.port_breakout_map[logical_link["StartPort"]]
            if self.contains_fanout(logical_link["EndDevice"]):
                fanout = self.find_fanout(logical_link["EndDevice"])
                fanout_ports_logical = fanout.port_breakout_map[logical_link["EndPort"]]
            else:
                fanout_ports_logical = self.__shared_fanout_port_breakout_map[logical_link["EndPort"]]
            if len(dut_ports_logical) != len(fanout_ports_logical):
                raise Exception("Physical link cannot be translated to logical link: {}".format(physical_link))
            for i, dut_port_logical in enumerate(dut_ports_logical):
                logical_link["StartPort"] = dut_port_logical
                logical_link["EndPort"] = fanout_ports_logical[i]
                logical_link["BandWidth"] = dut.port_speed(dut_port_logical)
                logical_links.append(dict(logical_link))
        logical_links = sorted(logical_links, key=lambda link: (device_cmp_key(link["StartDevice"]),
                                                                port_cmp_key(link["StartPort"])))
        vlan = starting_vlan
        for link in logical_links:
            link["VlanID"] = str(vlan)
            link["VlanMode"] = "Access"
            link["AutoNeg"] = "Off"
            vlan = vlan + 1
        self.__logical_links = logical_links
        for root_fanout_link_physical in self.__root_fanout_link_physical:
            root_fanout_link_logical = dict(root_fanout_link_physical)
            del root_fanout_link_logical["Cable"]
            root_fanout_link_logical["VlanID"] = gen_trunk_vlan(logical_links, root_fanout_link_physical["EndDevice"])
            root_fanout_link_logical["VlanMode"] = "Trunk"
            root_fanout_link_logical["AutoNeg"] = "Off"
            self.__root_fanout_link_logical.append(root_fanout_link_logical)
        return vlan

    def gen_console_links(self, console_name, console_port):
        ret = []
        for dut in self.__duts:
            ret.append(list_to_dict(console_links_header,
                                    console_name, console_port.pop(),
                                    dut.name, "ssh", "sonic_config", "sonicadmin", "9600"))
        for fanout in self.__fanouts:
            ret.append(list_to_dict(console_links_header,
                                    console_name, console_port.pop(),
                                    fanout.name, "ssh", "sonic_config", "sonicadmin", "9600"))
        return ret

    def get_shared_fanout_vlan(self, shared_fanout_name):
        return gen_trunk_vlan(self.__logical_links, shared_fanout_name)

    def get_physical_link(self, alias=True, shared_fanout_alias_to_name_map=None):
        return self.__get_link(True, alias, shared_fanout_alias_to_name_map)

    def get_logical_link(self, alias=True, shared_fanout_alias_to_name_map=None):
        return self.__get_link(False, alias, shared_fanout_alias_to_name_map)

    def __get_link(self, physical=True, alias=True, shared_fanout_alias_to_name_map=None):
        ret_value = []
        links = self.__physical_links if physical else self.__logical_links
        root_fanout_links = self.__root_fanout_link_physical if physical else self.__root_fanout_link_logical
        if alias:
            ret_value.extend(links)
            ret_value.extend(root_fanout_links)
        else:
            for link in links:
                new_link = dict(link)
                dut = self.find_dut(new_link["StartDevice"])
                new_link["StartPort"] = dut.alias_to_name(new_link["StartPort"], physical)
                if self.contains_fanout(new_link["EndDevice"]):
                    fanout = self.find_fanout(new_link["EndDevice"])
                    new_link["EndPort"] = fanout.alias_to_name(new_link["EndPort"], physical)
                else:
                    new_link["EndPort"] = shared_fanout_alias_to_name_map[new_link["EndPort"]]
                ret_value.append(new_link)
            for root_fanout_link in root_fanout_links:
                new_root_fanout_link = dict(root_fanout_link)
                fanout = self.find_fanout(new_root_fanout_link["EndDevice"])
                new_root_fanout_link["EndPort"] = fanout.alias_to_name(new_root_fanout_link["EndPort"], physical)
                ret_value.append(new_root_fanout_link)
        # we don't use sonic name for root fanout
        return ret_value

    def print_physical_link(self, alias=True, shared_fanout_alias_to_name_map=None):
        self.__print_link(True, alias, shared_fanout_alias_to_name_map)

    def print_logical_link(self, alias=True, shared_fanout_alias_to_name_map=None):
        self.__print_link(False, alias, shared_fanout_alias_to_name_map)

    def __print_link(self, physical=True, alias=True, shared_fanout_alias_to_name_map=None):
        csv_file = csv.DictWriter(sys.stdout, physical_links_header if physical else links_header, lineterminator="\n")
        links = self.__get_link(physical, alias, shared_fanout_alias_to_name_map)
        links = filter(lambda link: link["EndDevice"] != "empty", links)
        csv_file.writerows(links)


class GenLinks:
    def __init__(self, inv):
        self.inv = inv
        self.__genlinks = []
        self.console_name = None
        self.console_port = None
        self.__console_links = []
        self.root_fanout_name = None
        self.__root_fanout_port = None
        self.shared_fanout_name = None
        self.__shared_fanout_port = None
        self.__shared_fanout_alias_to_name_map = None

    def prepare_console_info(self, console_name):
        console_port = [str(i) for i in range(1, 49)]
        console_port.reverse()
        with open("../files/sonic_{}_console_links.csv".format(self.inv)) as f:
            csv_file = csv.DictReader(f)
            console_lines = filter(lambda line: line["StartDevice"] == console_name, csv_file)
            for line in console_lines:
                port = line["StartPort"]
                if port in console_port:
                    console_port.remove(port)
        self.console_name = console_name
        self.console_port = console_port

    # root fanout hwsku always has variable port config and speed
    # and physical links are always true to logical links
    def prepare_root_fanout_info(self):
        with open("../files/sonic_{}_devices.csv".format(self.inv)) as f:
            csv_file = csv.DictReader(f)
            root_fanout_lines = list(filter(lambda line: line["Type"] == "FanoutRoot", csv_file))
        if len(root_fanout_lines) != 1:
            raise Exception("Inv {} does not have exactly 1 root fanout".format(self.inv))
        root_fanout_line = root_fanout_lines[0]
        self.root_fanout_name = root_fanout_line["Hostname"]
        root_fanout_port = get_breakout_ports(root_fanout_line["HwSku"])
        with open("../files/sonic_{}_links.csv".format(self.inv)) as f:
            csv_file = csv.DictReader(f)
            for line in filter(lambda line: line["StartDevice"] == self.root_fanout_name, csv_file):
                port = line["StartPort"]
                speed = line["BandWidth"]
                root_fanout_port.remove_port(port, speed)
        self.__root_fanout_port = root_fanout_port

    def __prepare_shared_fanout_info_empty(self):
        self.__shared_fanout_port = get_breakout_ports("empty")

    # Arista-7260CX3 shared fanouts are different in that
    # hwsku does not determine port breakout
    # and the links does not differentiate between physical and logical
    # logical hwsku of shared fanout can be retrieved from device.csv
    # logical ports used can be filtered out
    # but for later use in alocating physical links and ports,
    # logical ports will be allocated first and
    # then translated into physical ports and links
    # TODO: physical ports are arbitrarily chosen and might not
    # match the required logical ports speed config
    def __prepare_shared_fanout_info_generic(self):
        with open("../files/sonic_{}_devices.csv".format(self.inv)) as f:
            csv_file = csv.DictReader(f)
            shared_fanout_lines = list(filter(lambda line: line["Hostname"] == self.shared_fanout_name,
                                              csv_file))
        if len(shared_fanout_lines) != 1:
            raise Exception("Inv {} does not have exactly 1 shared fanout {}"
                            .format(self.inv, self.shared_fanout_name))
        shared_fanout_hwsku = shared_fanout_lines[0]["HwSku"]
        shared_fanout_port = get_breakout_ports(shared_fanout_hwsku)
        self.__shared_fanout_alias_to_name_map = shared_fanout_port.alias_to_name_map()
        to_root_fanout_link_exist = False
        with open("../files/sonic_{}_links.csv".format(self.inv)) as f:
            csv_file = csv.DictReader(f)
            for line in filter(lambda line: line["EndDevice"] == self.shared_fanout_name, csv_file):
                if line["StartDevice"] == self.root_fanout_name:
                    self.__shared_fanout_link = line
                    to_root_fanout_link_exist = True
                else:
                    port = line["EndPort"]
                    speed = line["BandWidth"]
                    shared_fanout_port.remove_port(port, speed)
        self.__shared_fanout_port = shared_fanout_port
        if not to_root_fanout_link_exist:
            raise Exception("Shared fanout should be connected to root fanout")

    def prepare_shared_fanout_info(self, shared_fanout_name):
        self.shared_fanout_name = shared_fanout_name
        if shared_fanout_name == "empty":
            self.__prepare_shared_fanout_info_empty()
        else:
            self.__prepare_shared_fanout_info_generic()

    def add_devices(self, dut_names, fanout_names, override_hwsku=None):
        if len(dut_names) != len(fanout_names):
            raise Exception("Number of dut and fanout does not match")
        device_hwsku_map = {}
        with open("../files/sonic_{}_devices.csv".format(self.inv)) as f:
            csv_file = csv.DictReader(f)
            for line in csv_file:
                device_hwsku_map[line["Hostname"]] = line["HwSku"]
        if any([dut_name not in device_hwsku_map for dut_name in dut_names]) or \
           any([fanout_name and fanout_name not in device_hwsku_map for fanout_name in fanout_names]):
            raise Exception("Please enter device into in devices.csv before using this script")
        if override_hwsku:
            device_hwsku_map = dict(map(lambda item: (item[0], override_hwsku.get(item[1], item[1])),
                                    device_hwsku_map.items()))
        for i in range(len(dut_names)):
            dut_name = dut_names[i]
            fanout_name = fanout_names[i]
            if not fanout_name:
                new_obj = GenLink()
                new_obj.add_dut(dut_name, device_hwsku_map[dut_name])
                self.__genlinks.append(new_obj)
            elif not self.__genlinks or \
                (not self.__genlinks[-1].contains_dut(dut_name) and
                 not self.__genlinks[-1].contains_fanout(fanout_name)):
                new_obj = GenLink()
                new_obj.add_dut(dut_name, device_hwsku_map[dut_name])
                new_obj.add_fanout(fanout_name, device_hwsku_map[fanout_name])
                self.__genlinks.append(new_obj)
            else:
                self.__genlinks[-1].add_dut(dut_name, device_hwsku_map[dut_name])
                self.__genlinks[-1].add_fanout(fanout_name, device_hwsku_map[fanout_name])
        for genlink in self.__genlinks:
            genlink.init_devices()

    def gen_physical_links(self, m0_pattern="2"):
        for item in self.__genlinks:
            item.gen_physical_link(self.root_fanout_name, self.__root_fanout_port.pop_port, self.shared_fanout_name,
                                   None if self.shared_fanout_name is None else self.__shared_fanout_port.pop_port,
                                   m0_pattern)

    def gen_logical_links(self, vlan):
        starting_vlan = vlan
        if not starting_vlan:
            with open("../files/sonic_{}_links.csv".format(self.inv)) as f:
                csv_file = csv.DictReader(f)
                for line in csv_file:
                    access_lines = filter(lambda line: line["VlanMode"] == "Access", csv_file)
                    all_vlans = list(map(lambda line: int(line["VlanID"]), access_lines))
            if all_vlans:
                starting_vlan = max(all_vlans) + 1
            else:
                starting_vlan = 201
        for item in self.__genlinks:
            starting_vlan = item.gen_logical_link(starting_vlan)

    def gen_console_links(self):
        if not self.__console_links:
            for gen_link in self.__genlinks:
                self.__console_links.extend(gen_link.gen_console_links(self.console_name, self.console_port))

    def print_physical_links(self, alias=True):
        csv_file = csv.DictWriter(sys.stdout, physical_links_header, lineterminator="\n")
        csv_file.writeheader()
        for item in self.__genlinks:
            item.print_physical_link(alias, self.__shared_fanout_alias_to_name_map)

    def print_logical_links(self, alias=True, update_to_file=False):
        logical_links = []
        for item in self.__genlinks:
            logical_links.extend(item.get_logical_link(alias, self.__shared_fanout_alias_to_name_map))
        if self.shared_fanout_name and self.shared_fanout_name != "empty":
            shared_fanout_link = dict(self.__shared_fanout_link)
            shared_fanout_link["VlanID"] = combine_trunk_vlan([shared_fanout_link["VlanID"]] +
                                                              [item.get_shared_fanout_vlan(self.shared_fanout_name)
                                                               for item in self.__genlinks])
        logical_links = list(filter(lambda link: link["EndDevice"] != "empty", logical_links))
        if update_to_file:
            with open("../files/sonic_{}_links.csv".format(self.inv)) as f:
                logical_links.extend(csv.DictReader(f))
            if self.shared_fanout_name and self.shared_fanout_name != "empty":
                for link in logical_links:
                    if link["StartDevice"] == self.root_fanout_name and link["EndDevice"] == self.shared_fanout_name:
                        link["VlanID"] = shared_fanout_link["VlanID"]

            def logical_link_cmp(link1, link2):
                if link1["VlanMode"] == "Access" and link2["VlanMode"] == "Trunk":
                    return -1
                elif link1["VlanMode"] == "Trunk" and link2["VlanMode"] == "Access":
                    return 1
                elif link1["VlanMode"] == "Access" and link2["VlanMode"] == "Access":
                    return int(link1["VlanID"]) - int(link2["VlanID"])
                elif link1["StartDevice"] < link2["StartDevice"]:
                    return -1
                elif link1["StartDevice"] > link2["StartDevice"]:
                    return 1
                else:
                    return port_cmp_key(link1["StartPort"]) - port_cmp_key(link2["StartPort"])

            logical_links = sorted(logical_links, key=cmp_to_key(logical_link_cmp))
            with open("../files/sonic_{}_links.csv".format(self.inv), "w") as f:
                csv_file = csv.DictWriter(f, links_header, lineterminator="\n")
                csv_file.writeheader()
                csv_file.writerows(logical_links)
        else:
            csv_file = csv.DictWriter(sys.stdout, links_header, lineterminator="\n")
            csv_file.writeheader()
            csv_file.writerows(logical_links)
            if self.shared_fanout_name and self.shared_fanout_name != "empty":
                csv_file.writerow(shared_fanout_link)

    def print_console_links(self, update_to_file=False):
        if update_to_file:
            with open("../files/sonic_{}_console_links.csv".format(self.inv)) as f:
                console_links = list(csv.DictReader(f))
            console_links.extend(self.__console_links)

            def console_link_cmp(link1, link2):
                if link1["StartDevice"] < link2["StartDevice"]:
                    return -1
                elif link1["StartDevice"] > link2["StartDevice"]:
                    return 1
                else:
                    return int(link1["StartPort"]) - int(link2["StartPort"])

            console_links = sorted(console_links, key=cmp_to_key(console_link_cmp))
            with open("../files/sonic_{}_console_links.csv".format(self.inv), "w") as f:
                csv_file = csv.DictWriter(f, console_links_header, lineterminator="\n")
                csv_file.writeheader()
                csv_file.writerows(console_links)
        else:
            csv_file = csv.DictWriter(sys.stdout, console_links_header, lineterminator="\n")
            csv_file.writeheader()
            csv_file.writerows(self.__console_links)


if __name__ == "__main__":
    description = "labtool to generate links for testbeds"
    epilog = """
    Prior to using this tool, please fill in the device info in sonic_INV_devices.csv.
    Examples:
        ./gen_links -i lab -u # this will format the links csv file for inventory lab
        ./gen_links -i lab -d DUT1,DUT2 -f LEAF1,LEAF2 # print links for tb {DUT1, LEAF1} and {DUT2, LEAF2}
        ./gen_links -i lab -d DUT1 -f LEAF1 -c CONSOLE # also allocate console links from CONSOLE device
        ./gen_links -i lab -d DUT1 -f LEAF1 -v NUM # start allocating vlan id from NUM
        ./gen_links -i lab -d DUT1 -f LEAF1 -u # add the new lines to links.csv instead of just print to console
        ./gen_links -i lab -d DUT1 -f LEAF1 -b LEAF10 # generate links with shared fanout LEAF10
        ./gen_links -i lab -d DUT1 -f LEAF1 -b empty # pretend there is a shared fanout, but really generate no link
                                                     # useful when we should have a link to shared fanout but since
                                                     # the port will be admin down we don't actually have to connect it
        ./gen_links -i lab -d DUT1 -f LEAF1 -s # generate links with sonic name instead of alias
        ./gen_links -i lab -d DUT1 -f LEAF1 -o HWSKU1=HWSKU2 # sometimes we want hwsku to be different than recorded
                                                             # when we see HWSKU1, treat it as if it is HWSKU2
        ./gen_links -i lab -d DUT1 -f LEAF1 -m 1 # m0/mx connection pattern, index increasing with increasing use
                                                 # of DAC cable, for the 4 10G ports, pattern 1 connects 3 to fanout
                                                 # and 1 to shared fanout, pattern 2 connects all 4 to 1 7260 breakout
                                                 # port, pattern 3 connects all 4 to 4 7260 ports
    """
    parser = argparse.ArgumentParser(description=description, epilog=epilog,
                                     formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument("--inv", "-i", required=True, help="inventory")
    parser.add_argument("--dut", "-d", required=False, help="list of duts separated by comma")
    parser.add_argument("--fanout", "-f", required=False, help="list of fanouts separated by comma, item can be empty")
    parser.add_argument("--override-hwsku", "-o", required=False,
                        help="override recorded hwsku with another, "
                             "format ORIG_HWSKU=NEW_HWSKU, work on both dut and fanout")
    parser.add_argument("--console", "-c", required=False, help="console device for all the devices")
    parser.add_argument("--shared-fanout", "-b", required=False,
                        help="shared fanout name for case where one fanout is not enough")
    parser.add_argument("--vlan", "-v", required=False, type=int,
                        help="If starting vlan is not provided, will pick the largest vlan + 1 from inventory")
    parser.add_argument("--sonic-name", "-s", action="store_true", help="print port as sonic name and not alias")
    parser.add_argument("--m0-pattern", "-m", default="2", choices=["1", "2", "3"], help="m0/mx connection pattern")
    parser.add_argument("--update-to-file", "-u", action="store_true", help="directly update the info to links.csv")
    args = parser.parse_args()
    gen_links = GenLinks(args.inv)
    if args.console:
        gen_links.prepare_console_info(args.console)
    if args.override_hwsku:
        override_hwsku = dict(map(lambda item: item.split("="), args.override_hwsku.split(",")))
    else:
        override_hwsku = None
    gen_links.add_devices(args.dut.split(",") if args.dut else [],
                          args.fanout.split(",") if args.fanout else [],
                          override_hwsku=override_hwsku)
    if args.console:
        gen_links.gen_console_links()
        gen_links.print_console_links(args.update_to_file)
    gen_links.prepare_root_fanout_info()
    if args.shared_fanout:
        gen_links.prepare_shared_fanout_info(args.shared_fanout)
    gen_links.gen_physical_links(args.m0_pattern)
    gen_links.print_physical_links(alias=not args.sonic_name)
    gen_links.gen_logical_links(args.vlan)
    gen_links.print_logical_links(alias=not args.sonic_name, update_to_file=args.update_to_file)
