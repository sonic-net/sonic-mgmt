# Dataplane Test

This test performs the following actions:
-   Download a production snapshot of all OpenFlow entries on a switch. done
-   Translate OpenFlow entries to SAI table entries using OFPD. done
-   Install the downloaded table entries on the switch with fixed batch size of 1. done
-   For every table entry, generate a packet that will hit the table entry. If possible, generate a packet that won't be dropped. Send the packet to the switch, in two ways:
    -   all packets are sent on the dataplane done
    -   all packets are sent via packet-out's submit to ingress done
-   Send a packet-out for every port of the switch under test done
-   Record all the outputs generated by the switch under test done
    -   packets sent on the dataplane done
    -   packets punted via packet-ins done
-   Compare the switch's outputs to those predicted by a switch simulator done
    -   the SUT must generate exactly the same packets as the simulator has predicted, too few or too many packets fail the test done
    -   for WCMP the simulator does not know the exact hash used by the switch, so it allows a set of acceptable packets. The switch must generate exactly one of the acceptable packets done
-   Read all table entries from switch. done
-   Make sure read table entries match the table entries from the snapshot. tbd
-   Delete all read table entries with a single large batch. done

The list of programmable tables is as follows. All of them are tested. At the time of writing, they are:

-   neighbor_table done
-   router_interface_table done
-   nexthop_table done
-   wcmp_group_table done
-   ipv4_table done
-   ipv6_table done
-   mirror_session_table done
-   l3_admit_table not needed
-   acl_ingress_table done
-   acl_lookup_table done
-

Limitations:

-   At this point, we only generate packets that are meant to hit a table entry, there are no "negative" packets that are not meant to hit particular table entries, or narrowly miss a table entry by having most of the fields matched, but, say, only one field being wrong.
-   At this point, we only use table entries from production, so if a match field is not used (e.g. in_port in acl_lookup_table), then we don't test that.
-   The test only sends packets after the table entries have been successfully installed. There is no testing of what happens while table entries are being installed.

Instead of commenting on the doc: I am writing  some scenarios that I had mentioned in meetings [Hitha]

1.  Test to ensure transitions from more specific route to less specific route is hitless and vice versa [This is valid scenario for our fabrics as  we have default routes, aggregated routes and more specific ones)
1.  ECMP/WCMP have many scenarios - ecmp group members deleted, and added (Port undrain and drain, ports going down and up in the fabric)  - In cases where a new member is added (undrain or link up), traffic should be re-hashed and there shouldn't be any traffic loss. Where is when a member port is deleted (drain) there should be no loss. If the port goes down (link event), then there should be some loss but loss duration should be in milliseconds
1.  Routes being added are pointing to a port that is going down (when the flow program message reached the switch, the port went down). (port flaps in fabrics). Probably handled in the Fuzz test??

# Fuzz Test

The fuzzer generates random INSERT (done)/MODIFY (tbd)/DELETE (done) requests for all programmable tables. These requests are a mix of well-formed and ill-formed requests. done\
The requests are sent to the switch in batches (size randomly chosen between 1 and 100).

The list of programmable tables is as follows. All of them are tested. done

The list of ill-formed requests which we tests are: done

-   Non-existing table id
-   Priority is set, but not allowed
-   Priority is not set, but required
-   Match fields:
    -   Field id doesn't exist for table
    -   Required field id is not specified for table
    -   Wrong match kind (e.g. exact when ternary is required)
-   Lpm value is incompatible with length
-   Ternary value is incompatible with mask
-   Value doesn't match specified bitwidth
-   Action:
-   Action sets are used for non-WCMP table
-   Single action is used for WCMP table
-   Action id doesn't exist for table
-   Action Parameters:
    -   Parameter id doesn't exist for action
    -   Required parameter id is not specified for table
    -   Parameter value doesn't match specified bitwidth
-   Double-insert (insert of an entry that already exists)
-   Double-delete (delete of an entry that does not exist any more)
-   Modify of deleted entry

The fuzzer generates more INSERT than DELETE request, and so, over time, all the tables on the switch fill up. Then, the mix of INSERTs and DELETEs will bounce around the limit until the end of the test.

The fuzzer performs the following verification steps in every iteration:

-   The switch didn't crash or produce an INTERNAL error. done
-   Valid requests must be accepted by the switch. work in progress
    -   The switch can only reject entries with RESOURCE_EXHAUSTED only after the resource limit specified in the P4 program is reached. done
-   Invalid requests must be rejected by the switch. work in progress
-   Periodically all table entries are read back to make sure they match the expected state. Tbd

Limitations:

-   At this point, no dataplane verification is done, only P4RT Write is invoked.

# MTU Test

Send packets of all sizes (greater than minimum packet length, and shorter than < 10K) and make sure that those below the MTU get forwarded & punted, and the ones above get dropped. Tbd

# WCMP & Watch Port Test

We install a group with various weights on the switch, and then send packets to be forwarded by that group. We look at the output distribution of the group and make sure that it is similar enough to the group's weights. tbd

If our hash functions become 100% predictable, which is what we aim to do, we should consider just making sure that the switch's output 100% matches our expectations.

We will also bring down a couple of ports, and make sure that the remaining WCMP group members generate the expected distribution (this includes making sure no packets get dropped). We will then bring the ports back up again and make sure traffic is sent to those ports again. Tbd

There are various ways to bring down ports. Either 1) from the control switch, or 2) the SUT itself. On the SUT, we can bring down the port via 2a) config push, or 2b) gNOI. we still need to choose the approach

# P4Info Push Test

Push the P4Info and read it back, to make sure the two match. done

Limitations:

-   Only tests with the production P4Info, no negative tests.

# Master Arbitration Test

Send a handpicked set of master connect/disconnect event sequences. Verify that the right controllers become masters. Verify that masters can read & write, and that slaves can only read. The list of test cases can be found as follows. done

-   Become Master
-   Fail To Become Master
-   Replace Master
-   Replace Master After Failure
-   Fail To Become Master After Master Disconnect
-   Reconnect Master
-   Double Master
-   Long Evolution
-   Slave Cannot Write
-   Slave Can Read
-   Get Notified Of Actual Master
-   Zero Id Controller Can Become Master
-   Old Master Cannot Write After New Master Came Up
-   Master Downgrades Itself

# Smoke Test

The smoketest runs a handful of manually crafted tests to make sure the switch isn't completely broken.

-   Insert router interface table entry
-   Insert router interface table entry with weird name
-   Insert 3 ACL table entries, then read them back and make sure they match
-   Install 8 mirror sessions

# Programming Performance Test

The flow programming test measures the rate at which L3 table programming is done on the switch. The test uses a test client that runs on the switch and connects to the P4RT server to send L3 route entry requests and measures the round trip time to receive the response. The delta time difference includes the response from the hardware operation and hence is the total time required to complete the operation. Because the test client is run on the switch, any network delays between the test client and P4RT server on the switch is eliminated.

-   Connect to P4RT server
-   Create a one time router interface, neighbor entry and nexthop entry
-   Iterate over a loop and create IPV4 route entry for multiple prefixes
-   Repeat the same for multiple batches
-   Currently the test iterates over 8k & 16k route entries for the following variants

<table>
  <thead>
    <tr>
      <th><strong>Total</strong></th>
      <th><strong>Batch_size</strong></th>
      <th><strong>Number_batches</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>8192</td>
      <td>8</td>
      <td>1024</td>
    </tr>
    <tr>
      <td>8192</td>
      <td>32</td>
      <td>256</td>
    </tr>
    <tr>
      <td>8192</td>
      <td>8192</td>
      <td>1</td>
    </tr>
    <tr>
      <td>16384</td>
      <td>8</td>
      <td>2048</td>
    </tr>
    <tr>
      <td>16384</td>
      <td>32</td>
      <td>512</td>
    </tr>
    <tr>
      <td>16384</td>
      <td>16384</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

# QoS Testing

Separate document for QoS, Rate Limiting, Scheduling, Buffer Carving, etc.\
[CPU port qos testing](go/gpins-cpuport-qos)

# What we are testing

<table>
  <thead>
    <tr>
      <th><strong>Scenario</strong></th>
      <th><strong>How Tested</strong></th>
      <th><strong>How Easy to Debug</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Set/Get P4Info</td>
      <td>Push the P4Info and read it back, to make sure the two match</td>
      <td>Easy. Test fails immediately when this fails.</td>
    </tr>
    <tr>
      <td>For each table T</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>Install table entry in T</li>
</ul>
</td>
      <td>Dataplane test:<br>
<ul>
<li>Installs flows from production.</li>
</ul>
<br>
Smoke test:<br>
<ul>
<li>Installs a hand-crafted router interface table entry.</li>
</ul>
</td>
      <td>Easy. Test fails immediately when install fails.</td>
    </tr>
    <tr>
      <td><ul>
<li>Install table entry with random ID</li>
</ul>
</td>
      <td>Smoke test:<br>
<ul>
<li>Install hand-crafted router interface table entry with a randomly generated ID.</li>
</ul>
</td>
      <td>Easy. Test fails immediately when install fails</td>
    </tr>
    <tr>
      <td><ul>
<li>Read table entry in T</li>
</ul>
</td>
      <td>Dataplane test:<br>
<ul>
<li>Read all routes at the end of the test.</li>
</ul>
<br>
Smoke test :<br>
<ul>
<li>Clear switch state</li>
</ul>
<ul>
<li>Create the generic random table entries </li>
</ul>
<ul>
<li>Store entries for the comparison with read-back results later.</li>
</ul>
<ul>
<li>Install table entries on the switch.</li>
</ul>
<ul>
<li>Read the table entries back from the switch and compare.</li>
</ul>
</td>
      <td>Medium. <br>
Even though the test fails immediately when READ fails, it is slightly harder because:<br>
<ul>
<li>It will be the failure of a large batch of requests.</li>
</ul>
<ul>
<li>Switch needs to be in a clean state. In other words, CLEAR failure will also lead to the test failure.</li>
</ul>
</td>
    </tr>
    <tr>
      <td><ul>
<li>Delete table entry in T</li>
</ul>
</td>
      <td>All the blackbox tests delete all table entries at the end of the test:<br>
<ul>
<li>Read back all the entries on the switch</li>
</ul>
<ul>
<li>Determine the depency and order of update requests using <a href="go/p4-sequencing">sequencing library</a></li>
</ul>
<ul>
<li>Send the CLEAR request. </li>
</ul>
</td>
      <td>Hard. <br>
<ul>
<li>It will be the failure of a large batch of requests.</li>
</ul>
<ul>
<li>READ is prerequisite here (i.e. READ failure will cause a test failure)</li>
</ul>
<ul>
<li>The dependency of a large batch of requests is complicated</li>
</ul>
</td>
    </tr>
    <tr>
      <td><ul>
<li>Modify table entry in T</li>
</ul>
</td>
      <td>Smoke test:<br>
<ul>
<li>Insert an ACL ingress table entry with COPY action</li>
</ul>
<ul>
<li>Send MODIFY write request to change the action to FORWARD action</li>
</ul>
</td>
      <td>Medium. <br>
The test itself is simple but this feature is relatively new for GPINs switch stack and development is ongoing. </td>
    </tr>
    <tr>
      <td>Install 8 mirror sessions</td>
      <td>Smoke test:<br>
<ul>
<li>Install hand-crafted mirror session table entries with different session ids.</li>
</ul>
<ul>
<li>Install ACL entries that use the mirrors session above</li>
</ul>
</td>
      <td>Easy. Test fails immediately when this fails<br>
The test reveals the limits of switch support.</td>
    </tr>
    <tr>
      <td>Malformed requests/ table entries</td>
      <td>Fuzz tests validate the behavior of malformed requests/entries. The tests:<br>
<ul>
<li>Generate valid entries.</li>
</ul>
<ul>
<li>Mutate those valid entries into invalid ones by changing different fields, etc (e.g. table_id, action_id, macth_field_id, etc)</li>
</ul>
<ul>
<li>Send those invalid requests to switch</li>
</ul>
</td>
      <td>Hard. <br>
The Fuzz test is very valuable for us. In general, it is not easy to debug as it tests the edge cases intensively. However, the test collects excellent logs, can be reproduced with the same seed and stores all requests sent to/from the switch.</td>
    </tr>
    <tr>
      <td><ul>
<li>Install table entry whose table id doesn't exist for T</li>
</ul>
</td>
      <td>Fuzz test installs table entry without a table id.</td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>If T requires a priority, install entry without a priority</li>
</ul>
</td>
      <td>Fuzz test installs entries without a priority.</td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>If T requires no priority, install entry with a priority</li>
</ul>
</td>
      <td>Fuzz test install entry with a priority when no priority is required.</td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>Specify match field whose id doesn't exist for T</li>
</ul>
</td>
      <td>Fuzz test installs table entries with the match field has no-existing id.</td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>For each match field M in T</li>
</ul>
</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>Install entry that doesn't specify M</li>
</ul>
</td>
      <td>Fuzz test installs table entry without match filed</td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>Install entry with the wrong match kind for M</li>
</ul>
</td>
      <td>Fuzz test installs table entry with wrong match filed</td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>If M is LPM, install entry with incompatible length</li>
</ul>
</td>
      <td>Fuzz test installs table entry with longest-prefix match field that has incompatible length </td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>If M is ternary, install entry with incompatible mask</li>
</ul>
</td>
      <td>Fuzz test installs table entry with incompatible mask ternary match field.</td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>Install match field whose value has the wrong bitwidth</li>
</ul>
</td>
      <td>Fuzz test installs table entry with wrong bit width match field.</td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>For each action </li>
</ul>
</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>Install entry whose action set are used for non-WCMP table</li>
</ul>
</td>
      <td>Fuzz test installs table entries with action sets that are used for non-WCMP tables.</td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>Install entry that has single action used for WCMP table</li>
</ul>
</td>
      <td>Fuzz test installs table entries with a single action set that is used for WCMP tables.</td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>Install entry whose action id doesn't exist</li>
</ul>
</td>
      <td>Fuzz test installs table entry with action id that doesn't exist</td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>For each action parameter</li>
</ul>
</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>Install entry whose parameter id doesn't exist for action</li>
</ul>
</td>
      <td>Fuzz test installs table entry with action parameter that doesn't exist for action</td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>Install entry whose required parameter id is not specified for table</li>
</ul>
</td>
      <td>Fuzz test installs table entry with action parameter that is not specified for table</td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>Install entry whose parameter value doesn't match specified bitwidth</li>
</ul>
</td>
      <td>Fuzz test installs table entry with action parameter that doesn't match specified bitwidth.</td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>Double-insert</li>
</ul>
</td>
      <td>Fuzz test inserts an entry that already exists</td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>Double-delete</li>
</ul>
</td>
      <td>Fuzz test deletes an entry that doesn't exist any more.</td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>Modify of deleted entry</li>
</ul>
</td>
      <td>Fuzz test modies the already deleted entry</td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>Verify that no packets are dropped, during table entry update</li>
</ul>
</td>
      <td>not tested anywhere</td>
      <td></td>
    </tr>
    <tr>
      <td>Master arbitration</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>Become Master</li>
</ul>
</td>
      <td>Create P4Runtime session with switch to make sure the controller becomes master</td>
      <td>Easy. Test fails immediately when this fails.</td>
    </tr>
    <tr>
      <td><ul>
<li>Fail To Become Master</li>
</ul>
</td>
      <td>- Create a master controller. <br>
- Fail to create another master controller with a smaller election ID </td>
      <td>Easy. Test fails immediately when this fails.</td>
    </tr>
    <tr>
      <td><ul>
<li>Replace Master</li>
</ul>
</td>
      <td>- Create a master controller. <br>
- Replace master controller with the controller that has a larger election ID successfully</td>
      <td>Easy. Test fails immediately when this fails.</td>
    </tr>
    <tr>
      <td><ul>
<li>Replace Master After Failure</li>
</ul>
</td>
      <td>- Create a master controller.<br>
- Fail to create another master controller that has a smaller election ID  <br>
- Replace master controller with the controller that has a larger election ID successfully   </td>
      <td>Easy. Test fails immediately when this fails.</td>
    </tr>
    <tr>
      <td><ul>
<li>Fail To Become Master After Master Disconnect</li>
</ul>
</td>
      <td>- Create a master controller with election ID 1<br>
- Destroy that master<br>
- Fail to create a new master controller with a smaller election ID 0.<br>
<br>
It cannot become master because switch remembers the old election id and it requires a larger id to become the master.</td>
      <td>Easy. Test fails immediately when this fails.</td>
    </tr>
    <tr>
      <td><ul>
<li>Reconnect Master</li>
</ul>
</td>
      <td>- Create a master controller with election ID 0<br>
- Destroy that master<br>
- Fail to create a new master controller with the same election ID 0.<br>
<br>
Reconnect to master fails</td>
      <td>Easy. Test fails immediately when this fails.</td>
    </tr>
    <tr>
      <td><ul>
<li>Double Master</li>
</ul>
</td>
      <td>- Create a master controller with election ID 0<br>
- Fail to create another master with the same election ID 0.<br>
<br>
Fail to create a double master.</td>
      <td>Easy. Test fails immediately when this fails.</td>
    </tr>
    <tr>
      <td><ul>
<li>Long Evolution</li>
</ul>
</td>
      <td>This test contains the evolution of master arbitration between controllers with various election IDs. <br>
It integrates above test cases (e.g. Reconnect Master, Double Master, etc) into a single test.</td>
      <td>Medium. Test fails immediately when this fails. But it is slightly harder because it includes various scenarios of master arbitration.</td>
    </tr>
    <tr>
      <td><ul>
<li>Slave Cannot Write</li>
</ul>
</td>
      <td>- Create a master controller. <br>
- Create a slave controller.<br>
- Fail to send write request with slave controller's election ID</td>
      <td>Easy. Test fails immediately when this fails.</td>
    </tr>
    <tr>
      <td><ul>
<li>Slave Can Read</li>
</ul>
</td>
      <td>- Create a master controller. <br>
- Create a slave controller.<br>
- Send write request with slave controller's election id successfully </td>
      <td>Easy. Test fails immediately when this fails.</td>
    </tr>
    <tr>
      <td><ul>
<li>Get Notified Of Actual Master</li>
</ul>
</td>
      <td>- Assemble arbitration request<br>
- Send arbitration request<br>
- Wait for the arbitration response </td>
      <td>Easy. Test fails immediately when this fails.</td>
    </tr>
    <tr>
      <td><ul>
<li>No Id Controller Cannot Become Master</li>
</ul>
</td>
      <td>Send arbitration request with no election id</td>
      <td>Easy. Test fails immediately when this fails.</td>
    </tr>
    <tr>
      <td><ul>
<li>Old Master Cannot Write After New Master Came Up</li>
</ul>
</td>
      <td>- Connect controller C1 with id=1 to become master.<br>
- Connect controller C2 with id=2 > 1 to become master.<br>
- Check old master (i.e. C1) cannot write</td>
      <td>Easy. Test fails immediately when this fails.</td>
    </tr>
    <tr>
      <td><ul>
<li>Master Downgrades Itself</li>
</ul>
</td>
      <td>- Connect controller with id=2 to become master.<br>
- Sends a master arbitration request with id=1 to downgrade itself.<br>
- Checks C2 cannot write after downgrading.</td>
      <td>Medium. Test fails immediately when this fails.<br>
But it is slightly harder as several other operations (e.g. downgrade) are involved.</td>
    </tr>
    <tr>
      <td>Packet IO</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>Basic Packet In</li>
</ul>
</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>Packet In - Predicted Egress Port</li>
</ul>
</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>Packet In - Filter LACP & Ip2Me</li>
</ul>
</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>Packet Out - Submit to Egress</li>
</ul>
</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td><ul>
<li>Packet Out - Submit to Ingress</li>
</ul>
</td>
      <td></td>
      <td></td>
    </tr>
  </tbody>
</table>
