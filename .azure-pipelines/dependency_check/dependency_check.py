import ast
import sys
import os
import importlib.util
from natsort import natsorted
from contextlib import contextmanager


def collect_all_scripts():
    """
    Recursively find all files ending with ".py" under the folder "tests"
    Note: The full path and name of files are stored in a list named "files"

    Returns:
        A list of files ending with ".py" under the folder "tests"
    """
    location = sys.argv[1]
    files = []
    for root, dirs, file in os.walk(location):
        for f in file:
            if f.endswith(".py"):
                files.append(os.path.join(root, f))
    files = natsorted(files)
    return files


@contextmanager
def set_sys_path(file_path):
    """
    Add the project path into sys path

    Args:
        file_path (list): A list of files ending with ".py" under the folder "tests"
    Returns:
        None
    """
    original_sys_path = sys.path.copy()
    try:
        current_dir = os.path.abspath(os.path.dirname(file_path))
        while current_dir != os.path.dirname(current_dir):
            if current_dir.endswith("/tests"):
                sys.path.insert(len(sys.path), os.path.join(current_dir, "common"))

            sys.path.insert(len(sys.path), current_dir)
            current_dir = os.path.dirname(current_dir)
        yield
    finally:
        sys.path = original_sys_path


def get_module_path(imported_module, level=0, file_path=""):
    """
    Get the abs path of the imported module

    Args:
        imported_module (string): The imported module imported in the script.
        level (int): The import level that generated by ast.
        file_path (string): The path of a test script.
    Returns:
        string/None: The absolute path of the imported module or None
    """
    try:
        if level == 0:
            # Level 0 means an absolute import.
            # This means that the import statement is intended to refer directly
            # to the module or package path as specified without any relative hierarchy.
            # So we can get the module path using "importlib.util.find_spec"
            spec = importlib.util.find_spec(imported_module)
            if spec and spec.origin:
                return spec.origin
        if level == 1:
            # Level 1 means the import is relative to the current package level,
            # so the module path shares the same dirname with the file.
            # To save time, we don't need to check such import module.
            return None
        else:
            # For level which is higher than 1,
            # the number represents how many levels up in the package hierarchy the import should go.
            # Based on the current file path and the specified level, we can navigate up to the corresponding directory
            # and then combine the module name with the upper-level path to form an absolute path
            base_dir = os.path.abspath(file_path)
            for _ in range(level):
                base_dir = os.path.dirname(base_dir)
            return os.path.join(base_dir, *imported_module.split("."))
    except ModuleNotFoundError:
        return None


def get_imported_modules(files):
    """
    Get all imported modules in each file.

    Args:
        files (list): A list of files ending with ".py" under the folder "tests"
    Returns:
        dict: All imported modules in test scripts. The output formatted as below
        {
            '../tests/acl/custom_acl_table/test_custom_acl_table.py': [
                {
                  'type': 'from_import',
                  'module': 'ptf.mask',
                  'module_path': '/usr/local/lib/python3.8/dist-packages/ptf/mask.py',
                  'alias': 'Mask',
                  'asname': None
                },
                {
                      'type': 'from_import',
                      'module': 'tests.common.fixtures.ptfhost_utils',
                      'module_path': '/data/sonic-mgmt/tests/common/fixtures/ptfhost_utils.py',
                      'alias': 'skip_traffic_test',
                      'asname': None
                    }
            ],
            '../tests/bgp/test_bgp_session_flap.py': [
                {
                  'type': 'from_import',
                  'module': 'tests.common.utilities',
                  'module_path': '/data/sonic-mgmt/tests/common/utilities.py',
                  'alias': 'InterruptableThread',
                  'asname': None
                }
            ]
        }
    """
    imported_modules_in_files = {}
    for file_path in files:
        # For each file, we need to add its related path into sys path
        with set_sys_path(file_path):
            # We use ast to analyse the file as an abstract syntax tree,
            # and get all imported modules using class `ast.Import` and `ast.ImportFrom`
            with open(file_path, "r", encoding="utf-8") as file:
                tree = ast.parse(file.read(), filename=file_path)
            imported_modules_in_files[file_path] = []
            for node in ast.walk(tree):
                # Check for `import` statements
                if isinstance(node, ast.Import):
                    for entry in node.names:
                        imported_modules_in_files[file_path].append({
                            "type": "import",
                            "module": entry.name,
                            "module_path": get_module_path(entry.name),
                            "asname": entry.asname
                        })
                # Check for `from ... import ...` statements
                if isinstance(node, ast.ImportFrom):
                    for entry in node.names:
                        imported_modules_in_files[file_path].append({
                            "type": "from_import",
                            "module": node.module,
                            "module_path": get_module_path(node.module, node.level, file_path),
                            "alias": entry.name,
                            "asname": entry.asname
                        })
    return imported_modules_in_files


def get_feature_path(path):
    """
    For our repo, we can consider the folders like "acl", "bgp" as feature folders.
    In this function, we will retrieve the path of the top-level feature directories.
    In other words, we will retrieve the absolute paths of the first-level folders under `sonic-mgmt/tests`

    Args:
        path (string): The path of a file or an import module
    Returns:
        string/None: The absolute feature path or None
    """
    if path is None:
        return None

    file_path = os.path.abspath(path)
    target_path = "tests"
    index = file_path.find(target_path)

    if index != -1:
        project_path = file_path[:index + len(target_path)]
    else:
        return None

    feature = file_path[len(project_path) + 1:].split("/")[0]
    return os.path.join(project_path, feature)


def check_cross_dependency(imports_in_script):
    """
    Check if there are cross-feature dependency in each file.

    Args:
        imports_in_script (dict): All imported modules in test scripts.
    Returns:
        bool: True is there are cross-feature dependencies and False is there is no cross-feature dependencies
    """
    cross_dependency = False
    for file_path, imported_modules in imports_in_script.items():
        file_feature_path = get_feature_path(file_path)
        for imported_module in imported_modules:
            imported_module_feature_path = get_feature_path(imported_module["module_path"])
            if imported_module_feature_path is not None:
                project_path = os.path.dirname(file_feature_path)
                # Import from these paths are allowed.
                if imported_module_feature_path not in [os.path.join(project_path, "common"),
                                                        os.path.join(project_path, "ptf_runner.py"),
                                                        os.path.join(project_path, "conftest.py"),
                                                        file_feature_path]:
                    print("There is a cross-feature dependence. File: {}, import module: {}"
                          .format(file_path, imported_module["module"]))
                    cross_dependency = True
    return cross_dependency


if __name__ == '__main__':
    files = collect_all_scripts()
    imported_modules_in_files = get_imported_modules(files)
    cross_dependency = check_cross_dependency(imported_modules_in_files)
    if cross_dependency:
        print("\033[31mThere are cross-feature dependencies, which is not allowed in our repo\033[0m")
        print("\033[31mTo resolve this issue, please move the shared function to common place, "
              "such as 'tests/common'\033[0m")
