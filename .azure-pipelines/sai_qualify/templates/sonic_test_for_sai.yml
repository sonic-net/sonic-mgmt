parameters:
  - name: TESTBED_NAME
    type: string

  - name: TESTBED_FILE
    type: string
    default: testbed.yaml
    values:
      - testbed.csv
      - testbed.yaml

  - name: NIGHTLY_TEST_TIMEOUT
    type: number
    default: 1800    # minutes, totally 30 hours

  - name: AGENT_POOL
    type: string
    default: nightly
    values:
      - nightly
      - nightly2
      - nightly-svc
      - nightly-bjw

  - name: LOCK_TESTBED
    type: boolean
    default: true

  - name: LOCK_TESTBED_REASON
    displayName: "Lock Testbed Reason"
    type: string
    default: "SONiC Test for SAI release"

  - name: TESTBED_LOCK_HOUR
    type: string
    default: "6"

  # ============ Upgrade parameters ============
  - name: UPDATE_IMAGE
    type: boolean
    default: true

  - name: IMAGE_URL
    type: string
    default: ""

  - name: PREV_IMAGE_URL
    type: string
    default: ""

  - name: ALWAYS_INSTALL_NEW_IMAGE
    type: boolean
    default: true

  - name: UPGRADE_TYPE
    type: string
    default: sonic
    values:
      - sonic
      - onie

  - name: PAUSE_TIME
    type: number
    default: 0

  # Control the behavior if power cycle unreachable DUT
  # is allowed. Default: allowed (true)
  - name: POWER_CYCLE_UNREACHABLE_DUTS
    type: boolean
    default: true

  # ============ Deploy parameters ============
  - name: ENABLE_DATAACL
    type: boolean
    default: true

  # ============ Test Parameters ============
  - name: PY_SAITHRIFT_URL
    type: string
    default: ""

  - name: PTF_PORTMAP
    type: string
    default: ""

  # This is for the extra parameters to be passed to pytest by the "-e" option of run_tests.sh. For example,
  # to skip sanity check and disable log analyzer, the job yaml file calling this template can pass value
  # "--skip_sanity --disable_loganalyzer" to this EXTRA_PARAMS parameter.
  - name: EXTRA_PARAMS
    type: string
    default: ""

  # This is for other run_tests.sh options. For example, the run_tests.sh script supports "-S" option to skip
  # tests in specified folder. Assume a testbed needs to skip tests in folders like "platform_tests" and "dualtor"
  # sub-folders, the job yaml file calling this template can pass value '-S "platform_tests dualtor"' to
  # this TESTBED_SPECIFIC parameter.
  - name: TESTBED_SPECIFIC
    type: string
    default: ""

  # Default skip list. This list will be applied to all nightly tests
  - name: DEFAULT_SKIP_SCRIPTS
    type: string
    default: "vrf/test_vrf.py vrf/test_vrf_attr.py mvrf/test_mgmtvrf.py platform_tests/test_auto_negotiation.py sflow/test_sflow.py nat/test_dynamic_nat.py nat/test_static_nat.py"

  # Individual nightly test scheduler file could override this variable
  # to add more scripts to the skip list.
  - name: SKIP_SCRIPTS
    type: string
    default: ""

  - name: TEST_CASES
    type: string
    default: "fib/test_fib.py vxlan/test_vxlan_decap.py fdb/test_fdb.py decap/test_decap.py pfcwd/test_pfcwd_all_port_storm.py acl/null_route/test_null_route_helper.py acl/test_acl.py vlan/test_vlan.py platform_tests/test_reboot.py"

  # Individual nightly test scheduler file could override this variable
  # to skip uploading test results to kusto.
  - name: UPLOAD_TEST_REPORT
    type: boolean
    default: false

  - name: ARTIFACT_PROJECT
    type: string
    default: internal

  - name: DEPLOY_SAI_SDK
    type: boolean
    default: false

  - name: SDK_ARTIFACT_NAME
    type: string
    default: ""

  - name: SDK_BUILD_PIPELINE_NAME
    default: "build_brcm_sai_4.3"
    type: string

jobs:
  - job: SONiCTest
    pool: ${{ parameters.AGENT_POOL }}
    timeoutInMinutes: 360  # 6 hours
    workspace:
      clean: all
    variables:
      - group: TBSHARE_SECRETS
      - group: KUSTO_SAI_SECRETS
      - group: GIT_SECRETS
      - group: SECRETS_JSON
      - name: skipComponentGovernanceDetection
        value: true

    steps:
      - template: ../../nightly/templates/get_secrets.yml

      - task: PythonScript@0
        displayName: Parse Testbed Info
        inputs:
          scriptSource: 'inline'
          script: |
            from __future__ import print_function
            import os, imp, sys

            testbed_module = imp.load_source('testbed', 'tests/common/testbed.py')
            testbed_name = '${{ parameters.TESTBED_NAME }}'
            testbed_file = '${{ parameters.TESTBED_FILE }}'
            tbinfo = testbed_module.TestbedInfo('ansible/{}'.format(testbed_file))
            target_testbed = tbinfo.testbed_topo.get(testbed_name, None)
            if not target_testbed:
                print('Testbed {} not found!'.format(testbed_name))
                sys.exit(1)
            dut_list = target_testbed.get('duts', [])
            dut_list_str = ' '.join(x for x in dut_list)

            print('Basic info of testbed {}:'.format(testbed_name))
            print('    INVENTORY_NAME={}'.format(target_testbed['inv_name']))
            print('     TOPOLOGY_NAME={}'.format(target_testbed['topo']['name']))
            print('     TOPOLOGY_TYPE={}'.format(target_testbed['topo']['type']))
            print('          DUT_LIST={}'.format(dut_list_str))

            # Below code can create dynamic azure pipeline variables
            # Reference: https://docs.microsoft.com/en-us/azure/devops/pipelines/process/variables?view=azure-devops&tabs=yaml%2Cbatch#set-a-job-scoped-variable-from-a-script
            print('##vso[task.setvariable variable=INVENTORY_NAME;]{}'.format(target_testbed['inv_name']))
            print('##vso[task.setvariable variable=TOPOLOGY_NAME;]{}'.format(target_testbed['topo']['name']))
            print('##vso[task.setvariable variable=TOPOLOGY_TYPE;]{}'.format(target_testbed['topo']['type']))
            print('##vso[task.setvariable variable=DUT_LIST;]{}'.format(dut_list_str))

      - script: |
          TIMEOUT=600
          INTERVAL=60

          wait_time=0
          until python ./.azure-pipelines/nightly/templates/lock_release.py -t ${{ parameters.TESTBED_NAME }} -a lock -o ${{ parameters.TESTBED_LOCK_HOUR }} -r "${{ parameters.LOCK_TESTBED_REASON }}" -f no; do
              if (( $wait_time >= $TIMEOUT)); then
                  echo "Failed to lock testbed ${{ parameters.TESTBED_NAME }} after retrying for $TIMEOUT seconds with interval $INTERVAL"
                  exit 1
              fi
              echo "Lock testbed ${{ parameters.TESTBED_NAME }} failed, wait $INTERVAL seconds to retry"
              sleep $INTERVAL
              wait_time=$(expr $wait_time + $INTERVAL)
          done
        env:
            TBSHARE_AAD_CLIENT_ID: $(TBSHARE_AAD_CLIENT_ID)
            TBSHARE_AAD_CLIENT_SECRET: $(TBSHARE_AAD_CLIENT_SECRET)
        condition: ${{ parameters.LOCK_TESTBED }}
        displayName: Lock Testbed

      - task: Bash@3
        displayName: Get lock testbed result
        condition: and(${{ parameters.LOCK_TESTBED }}, succeeded())
        inputs:
          targetType: 'inline'
          script: |
            echo "##vso[task.setvariable variable=TESTBED_LOCKED;]true"

      - task: Bash@3
        condition: ${{ parameters.UPDATE_IMAGE }}
        displayName: "Upgrade Image"
        timeoutInMinutes: 90
        inputs:
          targetType: 'inline'
          script: |
            set -ex

            if [[ -z "$IMAGE_URL" ]]; then
                echo "Skipping image upgrading ..."
                exit 0
            fi

            if [[ -z "$PREV_IMAGE_URL" ]]; then
                PREV_IMAGE_URL="$IMAGE_URL.PREV.1"
            fi

            cd ansible

            if [[ ${{ parameters.ALWAYS_INSTALL_NEW_IMAGE }} == True && "$UPGRADE_TYPE" == "sonic" ]]; then
                ANSIBLE_FORCE_COLOR=true ansible-playbook upgrade_sonic.yml \
                    -i $(INVENTORY_NAME) \
                    -e testbed_name=${{ parameters.TESTBED_NAME }} \
                    -e image_url="$PREV_IMAGE_URL" \
                    -e upgrade_type=$UPGRADE_TYPE \
                    --vault-password-file password.txt \
                    -e pause_time=60 -vv || true
            fi
            ANSIBLE_FORCE_COLOR=true ansible-playbook upgrade_sonic.yml \
                -i $(INVENTORY_NAME) \
                -e testbed_name=${{ parameters.TESTBED_NAME }} \
                -e image_url=$IMAGE_URL \
                -e upgrade_type=$UPGRADE_TYPE \
                --vault-password-file password.txt \
                -e pause_time=${{ parameters.PAUSE_TIME }} -vv

            SONIC_VERSION=$(ansible -i $(INVENTORY_NAME) $(echo $(DUT_LIST) | cut -d " " -f1) -m command -a "cat /etc/sonic/sonic_version.yml")
            BRANCH_NAME=$(echo "$SONIC_VERSION" | grep branch: | cut -d "'" -f2)
            if [ "$ENABLE_FIPS" == 'yes' ] || ([ "$ENABLE_FIPS" != 'no' ] && [[ "$BRANCH_NAME" == "internal" || "$BRANCH_NAME" == "master" ]]); then
                for dut in $DUT_LIST; do
                    ansible -i $(INVENTORY_NAME) $dut -m command -a "sudo sonic-installer set-fips"
                    ansible -i $(INVENTORY_NAME) $dut -m command -a "sudo shutdown -r now"
                done
            fi

            sleep 600
        env:
          IMAGE_URL: ${{ parameters.IMAGE_URL }}
          PREV_IMAGE_URL: ${{ parameters.PREV_IMAGE_URL }}
          UPGRADE_TYPE: ${{ parameters.UPGRADE_TYPE }}

      - task: Bash@3
        displayName: Deploy Minigraph
        timeoutInMinutes: 30
        inputs:
          targetType: 'inline'
          script: |
            set -x

            if [[ ${{ parameters.ENABLE_DATAACL }} == True ]]; then
                CONFIG_PARAMS="$CONFIG_PARAMS -e enable_data_plane_acl=true"
            else
                CONFIG_PARAMS="$CONFIG_PARAMS -e enable_data_plane_acl=false"
            fi
            cd ansible

            http_proxy='' https_proxy='' ./testbed-cli.sh restart-ptf ${{ parameters.TESTBED_NAME }} password.txt -e ptf_imagetag=internal
            # If restart-ptf failed, try to redeploy the topology
            if [[ $? != 0 ]]; then
                http_proxy='' https_proxy='' ./testbed-cli.sh redeploy-topo ${{ parameters.TESTBED_NAME }} password.txt -e ptf_imagetag=internal
            fi

            http_proxy='' https_proxy='' ./testbed-cli.sh deploy-mg ${{ parameters.TESTBED_NAME }} $(INVENTORY_NAME) password.txt $CONFIG_PARAMS || exit 1
            sleep 180

      - task: DownloadPipelineArtifact@2
        condition: and(${{ parameters.DEPLOY_SAI_SDK }}, succeeded())
        inputs:
          source: specific
          project: ${{ parameters.ARTIFACT_PROJECT }}
          pipeline: ${{ parameters.SDK_BUILD_PIPELINE_NAME}}
          artifact: ${{ parameters.SDK_ARTIFACT_NAME }}
          path: $(Build.ArtifactStagingDirectory)/download
          patterns: |
            *.*
          script: |
            set -x
            ls $(Build.ArtifactStagingDirectory)/download
        displayName: "Download pre-stage built ${{ parameters.SDK_ARTIFACT_NAME }}"

      # install new bcmsai sdk on DUT, and reboot
      - task: Bash@3
        condition: and(${{ parameters.DEPLOY_SAI_SDK }}, succeeded())
        inputs:
          targetType: 'inline'
          script: |
            set -x
            BASE_PATH=$(pwd)

            export ANSIBLE_CONFIG=${BASE_PATH}/ansible
            export ANSIBLE_LIBRARY=${BASE_PATH}/ansible/library/
            export ANSIBLE_CONNECTION_PLUGINS=${BASE_PATH}/ansible/plugins/connection
            export ANSIBLE_CLICONF_PLUGINS=${BASE_PATH}/ansible/cliconf_plugins
            export ANSIBLE_TERMINAL_PLUGINS=${BASE_PATH}/ansible/terminal_plugins

            SAI_ADHOC_PATH=$BASE_PATH/tests/common/sai_adhoc.py
            DUT_PATH=/tmp/pkg

            python $SAI_ADHOC_PATH -t dut -o cmd -n ${{ parameters.TESTBED_NAME }} -c "mkdir -p $DUT_PATH"

            #copy files from server to dut
            python $SAI_ADHOC_PATH -i -t dut -o copy -n  ${{ parameters.TESTBED_NAME }} -c "src=$(Build.ArtifactStagingDirectory)/download dest=$DUT_PATH"
            python $SAI_ADHOC_PATH -i -t dut -o copy -n  ${{ parameters.TESTBED_NAME }} -c "src=$BASE_PATH/tests/scripts/sai_qualify/install_saibcm.sh dest=$DUT_PATH/download"

            # copy file to saiserver docker and commit docker
            python $SAI_ADHOC_PATH -t dut -o cmd -n ${{ parameters.TESTBED_NAME }} -c "docker cp $DUT_PATH/download syncd:/"

            python $SAI_ADHOC_PATH -t dut -o cmd -n ${{ parameters.TESTBED_NAME }} -c "docker exec syncd apt list --installed | grep sai"
            python $SAI_ADHOC_PATH -t dut -o cmd -n ${{ parameters.TESTBED_NAME }} -c "docker exec -u root syncd chmod +x /download/install_saibcm.sh"
            python $SAI_ADHOC_PATH -t dut -o cmd -n ${{ parameters.TESTBED_NAME }} -c "docker exec -u root syncd /download/install_saibcm.sh"
            python $SAI_ADHOC_PATH -t dut -o cmd -n ${{ parameters.TESTBED_NAME }} -c "docker exec syncd apt list --installed | grep sai"
            python $SAI_ADHOC_PATH -i -t dut -o cmd -n ${{ parameters.TESTBED_NAME }} -c "sudo reboot"
            sleep 180

        displayName: "install ${{ parameters.SDK_ARTIFACT_NAME }}"

      - task: Bash@3
        displayName: Run Tests
        timeoutInMinutes: ${{ parameters.NIGHTLY_TEST_TIMEOUT }}
        inputs:
          targetType: 'inline'
          script: |
            set -x

            BASE_PATH=`pwd`
            PARAMS="--allow_recover --showlocals --assert plain -rav --collect_techsupport=False --deep_clean --sad_case_list=sad_bgp,sad_lag_member,sad_lag,sad_vlan_port,sad_inboot"

            if [[ -n $PY_SAITHRIFT_URL ]]; then
                PARAMS="$PARAMS --py_saithrift_url=$PY_SAITHRIFT_URL"
            fi

            if [[ -n $PTF_PORTMAP ]]; then
                PARAMS="$PARAMS --ptf_portmap=$PTF_PORTMAP"
            fi

            if [[ -n $EXTRA_PARAMS ]]; then
                PARAMS="$PARAMS $EXTRA_PARAMS"
            fi

            DOW=$(date +%u)
            if [ $((DOW)) -le 4 ] || [ $((DOW)) -eq 7 ]; then
                PARAMS="$PARAMS --completeness_level=confident"
            fi

            if [[ $IMAGE_URL =~ \/public\/ ]]; then
                PARAMS="$PARAMS --public_docker_registry"
            fi

            EXECUTION_TOPOLOGY=$(TOPOLOGY_TYPE)
            if [[ "$TOPOLOGY_TYPE" != "tgen" ]]; then
                EXECUTION_TOPOLOGY="$EXECUTION_TOPOLOGY,any"
            fi

            if [[ "$TOPOLOGY_NAME" == *"dualtor"* ]]; then
                EXECUTION_TOPOLOGY="$EXECUTION_TOPOLOGY,dualtor"
            fi
            if [[ ${{ parameters.TESTBED_NAME }} == *8102* ]];then
                echo "Append loganalyzer_8102_ignore.txt to loganalyzer_common_ignore.txt"
                cat ansible/roles/test/files/tools/loganalyzer/loganalyzer_8102_ignore.txt >> ansible/roles/test/files/tools/loganalyzer/loganalyzer_common_ignore.txt
            fi

            rm -fr results     # Clear any possible collected results of previous run

            cd tests

            # '$(INVENTORY_NAME)' and '$(TOPOLOGY_TYPE)' are dynamic variables generated in step "Parse Testbed Info"
            http_proxy='' https_proxy='' ./run_tests.sh -n ${{ parameters.TESTBED_NAME }} \
                -c "${{ parameters.TEST_CASES }}" \
                -i $BASE_PATH/ansible/$(INVENTORY_NAME),$BASE_PATH/ansible/veos \
                -m individual \
                -t "$EXECUTION_TOPOLOGY" \
                -r \
                -e "$PARAMS"
            RUN_TESTS_RC=$?
            if [[ $RUN_TESTS_RC == 65 ]]; then
              echo "pretest failed. Please check the detailed log."
              exit 1
            elif [[ $RUN_TESTS_RC == 10 ]]; then
              echo "Sanity check failed. Please check the detailed log."
              exit 1
            else
              exit 0
            fi
        env:
          PY_SAITHRIFT_URL: ${{ parameters.PY_SAITHRIFT_URL }}
          PTF_PORTMAP: ${{ parameters.PTF_PORTMAP }}
          EXTRA_PARAMS: ${{ parameters.EXTRA_PARAMS }}
          GIT_USER_NAME: $(GIT_USER_NAME)
          GIT_API_TOKEN: $(GIT_API_TOKEN)
          IMAGE_URL: ${{ parameters.IMAGE_URL }}


      - publish: tests/logs
        displayName: "Archive test logs"
        artifact: ${{ parameters.TESTBED_NAME}}.nightly.log@$(System.JobAttempt)
        condition: always()

      - task: PublishTestResults@2
        displayName: Publish test results
        inputs:
          testResultsFiles: 'tests/logs/**/*.xml'
          testRunTitle: ${{ parameters.TESTBED_NAME}}.nightly
        condition: always()

      - script: |
          TIMEOUT=300
          INTERVAL=60

          wait_time=0
          until python ./.azure-pipelines/nightly/templates/lock_release.py -t ${{ parameters.TESTBED_NAME }} -a release; do
              if (( $wait_time >= $TIMEOUT)); then
                  echo "Failed to release testbed ${{ parameters.TESTBED_NAME }} after retrying for $TIMEOUT seconds with interval $INTERVAL"
                  exit 1
              fi
              echo "Release testbed ${{ parameters.TESTBED_NAME }} failed, wait $INTERVAL seconds to retry"
              sleep $INTERVAL
              wait_time=$(expr $wait_time + $INTERVAL)
          done
        env:
            TBSHARE_AAD_CLIENT_ID: $(TBSHARE_AAD_CLIENT_ID)
            TBSHARE_AAD_CLIENT_SECRET: $(TBSHARE_AAD_CLIENT_SECRET)
        displayName: Release Testbed
        condition: always()

      - task: CopyFiles@2
        displayName: Collect result files
        inputs:
          Contents: |
            tests/logs/**/*.xml
            tests/logs/platform_tests/test_*_reboot*.json
          TargetFolder: results
          CleanTargetFolder: true
        condition: always()

      - task: Bash@3
        displayName: Upload Test Results
        timeoutInMinutes: 20
        inputs:
          targetType: 'inline'
          script: |
            set -x

            if [[ ${{ parameters.UPLOAD_TEST_REPORT }} == False ]]; then
                echo "UPLOAD_TEST_REPORT=False, skip uploading test results to Kusto"
                exit 0
            fi

            echo "Activate python3 virtual environment"
            source /var/AzDevOps/env-python3/bin/activate

            cd test_reporting
            pip3 install -r requirements.txt

            python3 junit_xml_parser.py -d ../results -o tr.json

            python3 report_uploader.py -c "test_result" -e "$(Build.DefinitionName)#$(Build.BuildId)" -t ${{ parameters.TESTBED_NAME }} -i ${{ parameters.IMAGE_URL }} -j tr.json $report_upload_files SaiTestData

        condition: always()
        env:
          TEST_REPORT_INGEST_KUSTO_CLUSTER: $(TEST_REPORT_INGEST_KUSTO_CLUSTER)
          TEST_REPORT_AAD_TENANT_ID: $(TEST_REPORT_AAD_TENANT_ID)
          TEST_REPORT_AAD_CLIENT_ID: $(TEST_REPORT_AAD_CLIENT_ID)
          TEST_REPORT_AAD_CLIENT_KEY: $(TEST_REPORT_AAD_CLIENT_KEY)
          AZURE_DEVOPS_MSSONIC_TOKEN: $(MSSONIC_TOKEN)

      - task: Bash@3
        displayName: Cleanup Test Results
        inputs:
          targetType: 'inline'
          script: |
            set -x

            # Cleanup test logs and collected dumps to free disk space
            # Otherwise, the host server may have disk pressure and cause container being evicted by k8s.
            rm -fr tests/logs
        condition: always()
