# This job is for deep cleaning test servers in the weekend when nobody is using testbeds.
# It will try to recover all testbeds on test server after clean is done.
# This pipeline tries to lock all testbeds on test server before working on deep clean and recover. By default, the
# locking is best effort without force=yes. So, when any of the testbed on a server is locked, deep cleaning on the
# server will be skipped. This makes deep clean a low priority task which always gives way to other users and
# nightly tests.

name: DeepClean_$(Build.DefinitionName)_$(SourceBranchName)_$(Build.BuildId)_$(Date:yyyyMMdd)$(Rev:.r)

trigger: none
pr: none

parameters:

  - name: DRY_RUN
    type: boolean
    default: false
    displayName: "Dry run"

  - name: FORCE_LOCK
    type: boolean
    default: false
    displayName: "Force lock"

  - name: SERVER_TESTBED_INFO
    displayName: "Server testbed info"
    type: object

jobs:
- ${{ each SERVER in parameters.SERVER_TESTBED_INFO }}:
  - job: Deep_Clean_${{ SERVER.key }}
    pool: ${{ SERVER.value.pool }}
    timeoutInMinutes: 300
    variables:
      - group: TBSHARE_SECRETS
      - name: skipComponentGovernanceDetection
        value: true
      - name: VM_TYPE
        value: ${{ SERVER.value.vm_type }}
      - name: SERVER_NAME
        value: ${{ SERVER.key }}

    steps:

      # Get secrets
      - template: ../nightly/templates/get_secrets.yml

      # Cleanup result files
      - script: |
          set -x
          rm ansible/lockTestbedFailed
          touch ansible/lockTestbedFailed

          rm ansible/recoverResults
          touch ansible/recoverResults
        displayName: Cleanup result files

      # Loop through each testbed to lock it
      - ${{ each TESTBED_NAME in SERVER.value.testbeds }}:
        - script: |
            set -x

            # Deep clean is disruptive, do not force lock to allow people keep their testbeds in weekend
            python ./.azure-pipelines/nightly/templates/lock_release.py -t ${{ TESTBED_NAME }} -a lock -o 6 -r 'Deep clean' -f ${{ parameters.FORCE_LOCK }} -b yes
            RC=$?
            if [[ $RC != 0 ]]; then
              echo ${{ TESTBED_NAME }} >> ansible/lockTestbedFailed
            fi
          displayName: Lock Testbed ${{ TESTBED_NAME }}
          env:
              TBSHARE_AAD_CLIENT_ID: $(TBSHARE_AAD_CLIENT_ID)
              TBSHARE_AAD_CLIENT_SECRET: $(TBSHARE_AAD_CLIENT_SECRET)

      # Run cleanup
      - script: |
          set -x

          cd ansible

          # If lock any testbed on server failed, abort rest of the tasks
          lockTestbedFailed=$(cat lockTestbedFailed | wc -l)
          if [[ $lockTestbedFailed -gt 0 ]]; then
            echo
            echo !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            echo -e "Failed to lock testbeds:\n$(cat lockTestbedFailed)"
            echo "Failed to lock all testbeds on server, unable to cleanup server, aborting..."
            echo !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            echo
            echo 1 > cleanupServerResult
            exit 1
          fi

          CMD="./testbed-cli.sh cleanup-vmhost $(SERVER_NAME) password.txt"
          if [[ "${{ parameters.DRY_RUN}}" == True ]]; then
            echo "DRY RUN: $CMD"
            RC=0
          else
            echo ================ cleanup $(SERVER_NAME) ================
            $CMD
            RC=$?
          fi

          echo $RC > cleanupServerResult
        displayName: Cleanup $(SERVER_NAME)

      # Loop through each testbed to re-deploy it
      - ${{ each TESTBED_NAME in SERVER.value.testbeds }}:
        - script: |
            set -ex

            cd ansible

            # If cleanup failed, abort rest of the tasks
            cleanupServerResult=$(cat cleanupServerResult)
            if [[ $cleanupServerResult != 0 ]]; then
              echo
              echo !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
              echo "Cleanup server failed, aborting..."
              echo !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
              echo
              exit 1
            fi

            echo ================ Recover ${{ TESTBED_NAME }} =============== >> recoverResults

            echo ========== start-topo-vms for ${{ TESTBED_NAME }} ==========
            if [[ "$(VM_TYPE)" != "ceos" ]]; then
              echo "VM type is not ceos, need to start VMs"

              CMD="./testbed-cli.sh -k $(VM_TYPE) start-topo-vms ${{ TESTBED_NAME }} password.txt"
              if [[ "${{ parameters.DRY_RUN}}" == True ]]; then
                echo "DRY RUN: $CMD" >> recoverResults
              else
                $CMD
                RC=$?
                echo -e "${{ TESTBED_NAME }} start-topo-vms result:\t $RC" >> recoverResults
              fi
            else
              echo "VM type is ceos, no need to start VMs"
            fi

            echo ========== add-topo for ${{ TESTBED_NAME }} ==========
            CMD="./testbed-cli.sh -k $(VM_TYPE) add-topo ${{ TESTBED_NAME }} password.txt"
            if [[ "${{ parameters.DRY_RUN}}" == True ]]; then
              echo "DRY RUN: $CMD" >> recoverResults
            else
              $CMD
              RC=$?
              echo -e "${{ TESTBED_NAME }} add-topo result:\t $RC" >> recoverResults
            fi

            echo ========== deploy-mg for ${{ parameters.TESTBED_NAME }} ==========
            INVENTORY_NAME=$(python -c "import yaml; print(filter(lambda x: x['conf-name']=='${{ TESTBED_NAME }}', yaml.safe_load(open('testbed.yaml')))[0]['inv_name'])")
            CMD="./testbed-cli.sh -k $(VM_TYPE) deploy-mg ${{ TESTBED_NAME }} $INVENTORY_NAME password.txt"
            if [[ "${{ parameters.DRY_RUN}}" == True ]]; then
              echo "DRY RUN: $CMD" >> recoverResults
            else
              $CMD
              RC=$?
              echo -e "${{ TESTBED_NAME }} deploy-mg result:\t $RC" >> recoverResults
            fi
          displayName: Recover testbed ${{ TESTBED_NAME }}
          condition: succeededOrFailed()

      - script: |
            echo
            echo ============================================================================
            echo -e "Summary of recovering testbeds:\n$(cat ansible/recoverResults)"
            echo ============================================================================
            echo
        displayName: "Recover summary"
        condition: succeededOrFailed()

      # Loop through each testbed to release it
      - ${{ each TESTBED_NAME in SERVER.value.testbeds }}:
        - script: |
            set -x
            python ./.azure-pipelines/nightly/templates/lock_release.py -t ${{ TESTBED_NAME }} -a release -f ${{ parameters.FORCE_LOCK }}
          displayName: Release Testbed ${{ TESTBED_NAME }}
          env:
              TBSHARE_AAD_CLIENT_ID: $(TBSHARE_AAD_CLIENT_ID)
              TBSHARE_AAD_CLIENT_SECRET: $(TBSHARE_AAD_CLIENT_SECRET)
          condition: always()
